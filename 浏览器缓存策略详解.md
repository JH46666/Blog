# 浏览器缓存策略详解

关于cache的分类

* 按缓存位置分类 (memory cache, disk cache, Service Worker 等)
* 按失效策略分类 ( Cache-Control,  ETag 等)

发网络请求时会按照这个原则来：

1. Service Worker
2. Memory Cache
3. Disk Cache
4. 网络请求

## session 和 cookie
每个域名
cookie是在浏览器关闭的情况下就失效

浏览器的tab关闭后该浏览器memory cache便告失效
1.preloader    将请求的资源放入memory cache中，供之后的解析执行操作使用

2.preload   <linkrel="preload">。这些显式指定的预加载资源

“请求 js/css - 解析执行 - 请求下一个 js/css - 解析执行下一个 js/css”

service worker 能够操作的缓存是有别于浏览器内部的memory cache或者disk cache。缓存是永久性的，即便关闭了tab。有两种情况会导致这个缓存中的资源被清除：手动调用 API cache.delete(resource) 或者容量超过限制，被浏览器全部清空。


请求网络之后会根据情况决定是否缓存
1. 根据 Service Worker 中的 handler 决定是否存入 Cache Storage (额外的缓存位置)。
2. 根据 HTTP 头部的相关字段( Cache-control, Pragma 等)决定是否存入 disk cache
3. memory cache 保存一份资源 的引用，以备下次使用。

memory cache是浏览器控制的，不受开发者控制，也不受http协议头的约束
1. 所以我们平时最为熟悉的其实是 disk cache，也叫 HTTP cache (因为不像 memory cache，它遵守 HTTP 协议头中的字段)。
2. 平时所说的强制缓存，对比缓存，以及 Cache-Control 等，也都归于此类。

强缓存
强制缓存的含义是，当客户端请求后，会先访问缓存数据库看缓存是否存在。如果存在则直接返回；不存在则请求真的服务器，响应后再写入缓存数据库。

强制缓存直接减少请求数，是提升最大的缓存策略。 它的优化覆盖了文章开头提到过的请求数据的全部三个步骤。如果考虑使用缓存来优化网页性能的话，强制缓存应该是首先被考虑的。

可以造成强制缓存的字段是 Cache-control 和 Expires

## 

