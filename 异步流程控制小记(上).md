# 异步流程小记

  前端不可绕过的异步流程， 我们知道 javascript 运行在浏览器中，以 Google 浏览器为例子，
  v8 引擎，包含 内存堆： 这是内存分配发生的地方。 调用栈： 这是你代码执行的地方。

  运行一个函数时，解析器把该函数添加到栈中并且执行这个函数。

  Web APIs: DOM、AJAX、Timeout(setTimeout)

  js是一门单线程的语言， 这意味这它只有一个调用栈。

  当我们堆栈执行的函数需要大量时间时，浏览器会停止响应，幸运的是我们有异步回调。

  javaScript引擎 运行在宿主环境中（浏览器或者 node），
  CallbackQueue  and Event Loop

  事件循环和回调队列
  调用栈和回调队列，当栈为空时，它会调取出队列中的第一个事件，放到调用栈中执行

  //macro  setTimeout  setInterval

  //micro  Promise  console.log
  promise 永远会在队列尾部添加微观任务

## 常见的异步编程方案

`*` 回调函数
`*` 事件监听
`*` 发布/订阅
`*` promise对象

## 基础知识

为什么Promise的代码（microtask）会比setTimeout的代码（macrotask）更优先执行，因为它太机智了，竟然会插队！

## 环境配置

需要预先引入的库

  const fs = require('fs')
  const co = require('co')
  const util = require('util')

## callback（）

第一阶段：回调函数

``` javascript
function readFile(cb) {
    fs.readFile('./package.json', (err, data) => {
        if (err) return cb(err)
        cb(null, data)
    })
}

readFile((err, data) => {
    if (!err) {
        data = JSON.parse(data)
        console.log(data.name)
    }
})
```

  回调函数的弊端： 代码书写顺序与执行顺序不一致，不利于维护
  回调函数大多是匿名函数，bug 追踪困难
  异步操作的代码变更，后期维护麻烦。

## 事件监听

  采用了事件驱动模型，任务的执行不取决与代码的顺序，取决于某个事件是否发生。
  
``` js
  function f1() {

      setTimeout(function() {

          // f1的任务代码

          f1.trigger('done');

      }, 1000);

  }
```

## 发布/订阅

  假定我们存在一个任务中心，当某个事件完成之后，我们就发射状态信号，调度中心可以通知订阅了该状态信号的其他任务。这个也称为观察者模式。

 ```js
  jQuery.subscribe("done", f2);

  function f1(){

  　　　　setTimeout(function () {

  　　　　　　// f1的任务代码

  　　　　　　jQuery.publish("done");

  　　　　}, 1000);

  　　}

  当f1 执行完成后， 向信号中心"jquery"发布"done"信号，从而引发f2的执行。


 ```

## promise

第二阶段：Promise
定义阶段  promise（resolve， reject）分别成功或者失败时处理什么
调用阶段  通过then函数实现，成功就执行resolve， 它会将reslove的值传递给最近的then函数，作为then函数的参数。 如果出错reject，那么交给catch来捕获异常

  promise的要点如下

  1. 递归： 每个一步操作返回的都是promise对象
  2. 状态机： 三种状态peomise对象内部可以控制，不能在外部改变状态
  3. 全局异常处理

将回调函数中的结果延后到 then 函数里处理或交给全局异常处理

我们约定将每个函数的返回值都得是 promise 对象。 只要是 promise 对象， 就可以控制状态并支持 then 方法，将无限个 promise 对象链接在一起。

``` javascript
hello('xx.html').then(log).then(function() {
    return world('./xxx.js').then(log)
}).catch(err => {
    console.log(err)
})
```

每个 promise 对象都有 then 方法， 也就是说then方法是定义在原型对象promise.prototype上的， 它的作用是为
promise 实例添加状态改变时的回调函数

```js

Promise.prototype.then() = function (success, fail) {
  this.done(success)
  this.fail(fail)
  return this
}
```

一般情况下，只传 success 回调函数即可，fail函数可选，使用catch来捕获函数异常比通过fail函数进行处理更加可控。

const requireDirectory = require(require-directory )
module.export = requireDirectory(module)

``` javascript
function readFileAsync(path) {
    return new Promise((resolve, reject) => {
        fs.readFile(path, (err, data) => {
            if (err) reject(err)
            else resolve(data)
        })
    })
}

readFileAsync('./package.json')
    .then(data => {
        data = JSON.parse(data)
        console.log(data.name)
    })
    .catch(err => {
        console.log(err)
    })
```

  我们来看看下面这个例子：

```js
  new Promise(function (resolve) {
    resolve(1)
  }).then(function (value) {
    console.log(value)
  })



  Promise.resolve(1).then(function (value) {
    console.log(' Promise.resovle' + value)
  })

  var error = new Error('this is a error')

```

  new Promise更为强大,Promise.resolve更为便捷

//以下是更为便捷的写法

```js
function hello(i){
  return Promise.resolve(i)
}
hello(1).then(function(){
  console.log('promise.reslove1=' + value)
})

// Promise.resolve返回的是prmise对象，相当于 new Promise(resolve,reject)实例

// Promise.prototype.then()方法的语法如下
p.then(onFulfilled,onRejected);
// p.then(function(value)){}

p.catch(onRejected)
// p.catch(function(reson)) {}


```

```js
//整个promise 还有这种写法
hell('./xx.json').then(function (data) {
  return new Promise(function (reslove, reject) {
    console.log('promise ' + data)
    reslove(data)
  })
}).then(function (data) {
  return new Promise(function (reslove, reject) {
    console.log('promise ' + data)
    reslove(data)
  })
}).then(function (data) {
  return new Promise(function (reslove, reject) {
    console.log('promise ' + data)
    reslove(data)
  })
}).catch(function (err) {
  console.log(err)
})

```
