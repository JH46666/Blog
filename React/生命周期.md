一个完整的生命周期:

![props\state](https://tva1.sinaimg.cn/large/007S8ZIlgy1gib8grikbdj313o0bwtb1.jpg)



shouldComponentUpdate(nextProps, nextState)
這個函數的功用像是守門員，用來做確認是不是真的要update。這個函數要return一個布林值。當函數回傳false時，元件就不會更新，也不會繼續執行接下來的render()以及剩下的update生命週期函數。預設會回傳true。

在這邊，this.props和this.state是更新之前的，新的props和state在參數中以nextProps和nextState存在。你可以在這裡對這四者做比較


compoent

![componentWillMount 与 componentDidMount](https://tva1.sinaimg.cn/large/007S8ZIlgy1gib8wzhs04j30mf0n6t9u.jpg)



## react 接收到 props 时  会做相应的处理

1、直接使用
这种方式，父组件改变props后，子组件重新渲染，由于直接使用的props，所以我们不需要做什么就可以正常显示最新的props

class Child extends Component {
    render() {
        return <div>{this.props.someThings}</div>
    }
}

2、转换成自己的state
这种方式，由于我们使用的是state，所以每当父组件每次重新传递props时，我们需要重新处理下，将props转换成自己的state，这里就用到了 componentWillReceiveProps。

关于你提到的不会二次渲染是这样的：每次子组件接收到新的props，都会重新渲染一次，除非你做了处理来阻止（比如使用：shouldComponentUpdate），但是你可以在这次渲染前，根据新的props更新state，更新state也会触发一次重新渲染，但react不会这么傻，所以只会渲染一次，这对应用的性能是有利的。

class Child extends Component {
    constructor(props) {
        super(props);
        this.state = {
            someThings: props.someThings
        };
    }
    componentWillReceiveProps(nextProps) {
        this.setState({someThings: nextProps.someThings});
    }
    render() {
        return <div>{this.state.someThings}</div>
    }
}