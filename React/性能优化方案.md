# react 性能优化

1. 使用 React Fragments 避免额外标记
片段不会向组件引入任何额外标记，但它仍然为两个相邻标记提供父级，因此满足在组件顶级具有单个父级的条件.

```jsx
export default class NestedRoutingComponent extends React.Component {
    render() {
        return (
            <>
                <h1>This is the Header Component</h1>
                <h2>Welcome To Demo Page</h2>
            </>
        )
    }
}
```

1. 不要使用内联函数定义

上面的函数创建了内联函数。每次调用 render 函数时都会创建一个函数的新实例，render 函数会将该函数的新实例绑定到该按钮。

1. 避免 componentWillMount() 中的异步请求
在检索数据时 React 会触发组件的 render 函数。因此第一个调用的渲染仍然不包含它所需的数据。

这样一开始渲染组件没有数据，然后检索数据，调用 setState，还得重新渲染组件。在 componentWillMount 阶段进行 AJAX 调用没有好处可言。

我们应避免在此函数中发出 Async 请求。这些函数和调用可以延迟到 componentDidMount 生命周期事件里。

```jsx
import React from "react";
import axios from "axios";

export default class UsingAsyncInComponentWillMount extends React.Component {

  constructor() {
    this.state = {
      userData: null
    }
  }
  
  componentWillMount() {
    axios.get("someResourceUrl").then((data) => {
      this.setState({
        userData: data
      });
    });
  }
  
  render() {
    return (
      <>
        <b>UserName: {this.state.name}</b>
        <b>UserAge: {this.state.age}</b>
      </>
    )
  }
}
```

1. 在 Constructor 的早期绑定函数

每次调用 render 函数时都会创建并使用绑定到当前上下文的新函数，但在每次渲染时使用已存在的函数效率更高。优化方案如下：

```jsx
import React from "react";

export default class DelayedBinding extends React.Component {
  constructor() {
    this.state = {
      name: "Mayank"
    }
    this.handleButtonClick = this.handleButtonClick.bind(this)
  }
  
  handleButtonClick() {
    alert("Button Clicked: " + this.state.name)
  }
  
  render() {
    return (
      <>
        <input type="button" value="Click" onClick={this.handleButtonClick} />
      </>
    )
  }
}
```

1. 箭头函数与构造函数中的绑定
处理类时的标准做法就是使用箭头函数。使用箭头函数时会保留执行的上下文。

我们调用它时不需要将函数绑定到上下文。
```jsx
import React from "react";

export default class DelayedBinding extends React.Component {
  constructor() {
    this.state = {
      name: "Mayank"
    }
  }
  
  handleButtonClick = () => {
    alert("Button Clicked: " + this.state.name)
  }
  
  render() {
    return (
      <>
        <input type="button" value="Click" onClick={this.handleButtonClick} />
      </>
    )
  }
}
```

1. 避免使用内联样式属性

```js
import React from "react";

export default class InlineStyledComponents extends React.Component {
  render() {
    return (
      <>
        <b style={{"backgroundColor": "blue"}}>Welcome to Sample Page</b>
      </>
    )
  }
}
```
  
  内联样式需要话费更多时间来处理脚本和渲染,映射传递给实际 css 属性的所有样式规则.添加的内联样式是 JavaScript 对象而不是样式标记. 样式 backgroundColor 需要转换为等效的 css 样式属性,然后才应用样式.

1. 优化 React 中的条件渲染
  减少组件的安装和卸载. 条件渲染进行提升.

1. 不要在 render 方法中导出数据

```jsx
import React from "react";

export default class RenderFunctionOptimization extends React.Component {
  constructor() {
    this.state = {
      name: "Mayank"
    }
  }
  
  render() {
    this.setState({
      name: this.state.name + "_"
    });

    return (
      <div>
        <b>User Name: {this.state.name}</b>
      </div>
    );
  }
}
```

  更新组件状态的问题在于，当状态更新时会触发另一个 render 循环，后者在内部会再触发一个 render 循环，以此类推。

每次渲染时，都会在内存中创建一个新函数(因为它是在 render 函数中创建的)，并将对内存中新地址的新引用传递给 <Button />，虽然输入完全没有变化，该 Button 组件还是会重新渲染。

不要在 render 中 定义这些函数

官方推荐:

```js
  createAlertBox = () => {
    alert(this.props.message);
  };

  <Button onClick={createAlertBox} />

```

   通过传递 createAlertBox 方法，它就和 SomeComponent 重新渲染无关了，甚至和 message 这个属性是否修改也没有关系。createAlertBox 内存中的地址不会改变，这意味着 Button 不需要重新渲染，节省了处理时间并提高了应用程序的渲染速度

```js
class LoggingButton extends React.Component {
  handleClick() {
    console.log('this is:', this);
  }

  render() {
    // 此语法确保 `handleClick` 内的 `this` 已被绑定。
    return (
      <button onClick={() => this.handleClick()}>
        Click me
      </button>
    );
  }
}
```

此语法问题在于每次渲染 LoggingButton 时都会创建不同的回调函数。在大多数情况下，这没什么问题，但如果该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染。我们通常建议在构造器中绑定或使用 class fields 语法来避免这类性能问题。

显示与隐式参数传递

```js
<button onClick = { (e)=> this.handleClick( id,e ) }></button>
<button onClick = { this.handleClick.bind( this,id ) }></button>
```

上述两种方式是等价的，分别通过 箭头函数 和 Function.prototype.bind 来实现。

在上面两种情况下，React的事件对象 e 会被作为第二个参数传递。

如果通过箭头函数的方式，事件对象必须显式的进行传递，

而通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。


