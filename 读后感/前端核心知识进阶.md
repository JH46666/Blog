# 

## 构造函数和this

``` js
function myNew() {
    const Constructor = Array.prototype.shift.call(arguments);
    let obj = {};
    obj.__proto__ = Constructor.prototype;

    let res = Constructor.apply(obj, arguments)
    return res instanceof Object ? res : obj
}
```

## 箭头函数中的 this

## this 优先级

我们把 call， apply， bind， new 对this 进行绑定的情况称为显示绑定，而把根据调用关系确定this指向的情况称为隐式绑定。

## 显示和隐式绑定优先级

call， apply的显示绑定一般来说优先级最高

new 绑定修改了 bind 绑定中的 this 指向， 所以 new 的优先级比 bind 绑定的更高

``` JS
function foo(a) {
    this.a = a;
}
const obj1 = {};
var bar = foo.bind(obj1);
bar(2);
console.log(obj1.a);
```
当在使用 bar 作为构造函数时，

```js
var baz = new bar(3);
consle.log(baz.a)
```

```js
Function.prototype.bind =  function(argument){
  const that = this;
  let bindArgs = Array.prototype.slice.call(argument, 1);

  return function bound(argument){
    let innerArgs = Array.prototype.slice.call(argument);
    that.apply(context, [...bindArgs, ...innerArgs])
  }
}
```

要在 bound 函数中进行 this instanceof 判断

```js
Function.prototype.bind(context){
  
  // 1.
  let that = this;

  //2.
  let bindArgs = Array.prototype.slice.call(argument, 1);
  function Fn() {};

  //3.
  function fBound(params){
    let args = Array.prototype.slice.call(argument);
    return that.apply(this instanceOf fBound ? this : context, bindArgs.concat(args));
  }

  Fn.prototype = this.prototype;
  fBound.prototype = new Fn();

  return fBound;
}
```

## 闭包

函数作用域

全局作用域

函数作用域链：如果在自身的函数作用域内并未找到变量， 就会往更上层作用域，例如函数或者全局作用域

执行上下文和调用栈

* 代码预编译阶段

* 在预编译阶段进行变量声明
* 在预编译阶段堆变量进行声明提升， 但是值为undefined
* 在预编译阶段对所有非表达式的函数声明进行提升

执行上下文: 变量对象, 作用域链, this

* 代码执行阶段

在函数执行完毕并出栈时， 函数内的局部变量在下一个垃圾回收gc 节点会被回收， 该函数对应的执行上下文将会被销毁， 这也是我们在外界无法访问函数内定义的变量的原因。

闭包： 函数嵌套函数， 内层函数引用了外层函数作用域下的变量， 并且内层函数在全局环境下可访问， 进而形成闭包。

jquery offset 方法实现

优化方案：

页面工程优化：涉及页面请求开始网络协议、资源配置、浏览器性能、缓存等

代码细节优化： js 对dom 的操作过程、宿主环境以及单线程的相关内容

webP图片优化：

```js
const supportWebp = （）=> new Promise(reslove=>{
  const img = new Image();
  img.onerror = ()=> reslove(false)
  img.onload = ()=> reslove(img.width  === 1)
  img.src = 'data:imgxxxxxx/webp'
}).catch(()=> false)
```

按需加载

React 的优化

减少 prop 的改变， 更细粒程度的控制组件的渲染行为

recompose 内部的原理 在于在高阶组件中调用 shouldComponentUpdate 方法， 并在该方法中将比较对象由完整的props 转为传入的指定的 props 即可

规避 inline function 反模式

当使用render 方法时， 要留意render方法内创建的函数或数组等， 它们可能是显示生成 ， 也可能是隐式生成的。 

对性能比较友好的， 只创建一次自定义函数， 而不是每次渲染时都创建一次。

pureComponent 会自动帮助开发者使用 shouldComponentUpdate 生命周期方法， 也就是说当组件state 和props 发生变化时， 正常的 component 都会自动进行重新渲染， 在这种情况下， shouldComponentUpdate 会默认返回true。 但是pureComponent 会先进行比较， 即比较前后的state 和 props 是否相等，

开发者要避免共享（mutation）带来的问题
如果一个父组件对object 进行了mutation 操作，且子组件依赖此数据，并采用了 pureComponent 声明， 那么子组件将无法进行更新。 尽管props 中的某一项值发生了变化， 但是由于它的引用并没有发生变化， 因此pureComponent 的shouldComponentUpdate 会返回false。 更好的做法是在更新props 或者state、时， 返回一个新的对象或数组。

从Vue3.0 动静结合的Dom diff 谈起

预编译阶段 能够进行优化处理，在预编译时标记出模板可能变化的组件节点， 再次进行diff 操作时就可以跳过： 』永远不会变化的节点『

React 在将 jsx 编译成React。createElement 的整个过程
    优化                  优化
jsx => React.createElment => React

静态元素提升

在运行时删除 propTypes

在运行时代码取出内联函数

## 不可忽视的前端安全

### https

不要使用 URL query 传递敏感数据
  URL query会通过服务器短日志、浏览器日志、浏览器历史记录查到

  content-security-policy 响应头， 它可以设置应用是否可以引用某些来源的内容， 进而防止xss

JWT 和 Authentication cookie

为了防范 xss， 攻击者可以主动诸如恶意脚本或者使用户输入，通过JavaScript 代码来偷取token， 然后通过token 冒充受害用户， 一般的防御手段有 HTML 转义

### cookie

cookie 可以由js 创建

```js
document.cookie = `my_cookie_name=my_cookie_value`
```

也可以由服务端通过设置响应头创建

```js
Set-cookie: my_cookie_name=my_cookie_value;
```

session cookie ， 这种 cookie 会随着用用户关闭浏览器而被清除，不会被标记任何过期时间 expires 或最大时限 Max-age

permanent cookie， 与 session cookie，相反， 会在用户关闭浏览器之后被浏览器持久化存储

HttpOnly cookie， 浏览器端， JavaScript 没有读 cookie 的权限

secure cookie， 只有在特定安全通道（https）下， 传输链路的请求中才会自动加入相关cookie

samesite cookie， 在跨域情况下， 相关 cookie 无法被请求携带， 这里主要为了防止 csrf 攻击

Authentication cookie  隐患

xss 如果没有使用httpOnly 选项， 那么攻击者可能会通过注入恶意脚本任意读取用户cookie， 而cookie 直接存储了用户的身份认证信息
