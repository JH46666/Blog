1.

最底层的就是数组和链表

对于解决hash冲突的办法： 拉链法和 线性探查法
树如果用 数组来实现就是堆

数组由于是连续紧凑型，可以随机访问，通过索引能够快速找到对应的元素，而且如果相对节约存储空间。 但正因为连续存储，内存空间必须一次性给足，时间复杂度0(N); 如果想进行插入和删除操作，每次必须搬运后面的所有数据，时间复杂度度为O(N); 

链表因为元素不连续，靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入该元素，时间复杂度为O(1); 但是正因为空间的不连续，你无法根据索引算出对应元素的地址，所以不能随机访问，而且每个元素必须存储指向前后元素位置的指针，会消耗更多的存储空间。

数据结构种类很多， 他们的目的就是无非就是不用的应用场景下高效的增删改查；

线性形式以for/while 迭代为代表，非线性形式以递归为代表

二叉树有前中后序遍历 其实链表也有前序和后序遍历， 例如在前序遍历的时候打印 head.val 就是正序打印链表；在后序遍历的位置打印head.val就是倒序打印链表；
写过web中间件的朋友应该可以发现，中间件的调用链其实就是一个递归遍历链表的过程。
前置中间件 比如session的注入 在前序遍历的位置执行，
后置中间件（异常捕获）在后序遍历的位置执行
而一些中间件（计算调用总耗时）在前序和后序遍历的位置都有代码
