一面：
1. 计算机原理相关： 进程调度有哪几种方式(操作系统) 。


2. 原型原型链

我们每个 new 出来的实例，它有prototype以链的形式指向它的原型对象，它的原型对象又通过__proto 指向Object。

3. web性能优化
  1、 减少请求
  2.、压缩包大小
  3、采用 http2。0
  4、采用webp图片等技术
  5、减少重排和重绘


4. webpack如何写plugin

5. vue数据响应式原理
  运用了object。getter setter 进行了个拦截。然后加入到创建的dep 数组中，只要发生了变化，我们就 notify 一下订阅的。通知它们进行修改。
  
6. vue3的新特性
  双向绑定原理发生了变化，由原来得object。getter setter 变成了 proxy ，这样做有个好处  就是监听更方便了，以前我们针对层次深一点得对象 或者数组，修改值得时候可能发生变化，检测不到，用了proxy  可以检测到。 还有就是多个compoition api，跟react hook 一样 才用setup 将所有的方法都放在了里面。

7. 代码实现： 实现Array.prototype.reduce方法
```js
Array.prototype.reduce = function(func, initState){
  const arr = this;
  const callback = func

  let init = initState

  arr.forEach(function(value, index){
    init = callback(init, value)
  })
  return init
}
```
8. 实现 12345678.002345 -> 12,345,678.002345
```js
      const num = 12345678.002345;
      const newNum = String(num).split('.')
       console.log("e", newNum);
      const rexp = /(\d)(?=(?:\d{3})+$)/g;
   
      console.log("new", String(newNum[0]).replace(rexp, "$1,"));
```
9. 实现 数组里找任意两个数相加值为一个目标值的算法（输出下标）
如： [2,4,5,6,7,1,8] target = 8 最终输出为[[0,3], [4,5]]
```js
      const twoSum = (nums, target) => {
        // 1. 构造哈希表
        const map = new Map(); // 存储方式 {need, index}
        const arr = [];
        // 2. 遍历数组
        for (let i = 0; i < nums.length; i++) {
          // 2.1 如果找到 target - nums[i] 的值
          if (map.has(nums[i])) {
            arr.push([map.get(nums[i]), i]);
          } else {
            // 2.2 如果没找到则进行设置
            map.set(target - nums[i], i);
          }
        }
        return arr
      };

      console.log(twoSum([2, 4, 5, 6, 7, 1, 8], 8));

```
二面：
1. 计算机网络原理，为什么tcp有拥塞控制，tcp如何实现拥塞控制，网络发生拥塞了又咋办(总之问的很细)


2. dns解析的过程，域名解析的顺序，cdn的原理
dns 首先去找主机库的，看有没有过，没有的话，再去服务器上面查找，找到对应的ip地址服务器。进行连接。
cdn 的话就在在理你最近的服务器放有你想要的资源，让你快速请求到资源。

3. 基本依托于项目聊，聊微前端的技术架构
微前端主要解决的是管理后台这种很大的项目，在打包上线时候，时间缓慢,又极易出现bug，牵一发而动全身。所以我们将项目拆分出来，这样即解决了分布式管理，能根据特定业务进行上线，也不至于出现问题后还无法进行快速处理。而且还能根据特定的业务使用不同的技术栈，达到性能上面的提升。

4. qiankun框架的实现(对single spa的封装， 样式隔离的原理，js隔离的原理)

5. react native的大致原理


6. 为什么要用qiankun重构去掉iframe
iframe 不利于我们进行组件的通信，其原生带来的割裂感，使我们无法复用组件和css样式。qiankun使用的是路由劫持的思想，配合webpack构建出相同的资源访问形式，进行切换不同路由找到相应的页面，在进行加载。

7. 写了基于发布订阅者模式的EventBus（过程中还问了 数据的引用和值的区别）
```js
class Event {
    /** on 方法把订阅者所想要订阅的事件及相应的回调函数记录在 Event 对象的 _cbs 属性中*/
    on(event, fn) {
        if (typeof fn != "function") {
            console.error('fn must be a function')
            return
        }
        this._cbs = this._cbs || {};
        (this._cbs[event] = this._cbs[event] || []).push(fn)
    }
    /**emit 方法接受一个事件名称参数，在 Event 对象的 _cbs 属性中取出对应的数组，并逐个执行里面的回调函数 */
    emit(event) {
        this._cbs = this._cbs || {}
        var callbacks = this._cbs[event],
            args
        if (callbacks) {
            callbacks = callbacks.slice(0)
            args = [].slice.call(arguments, 1)
            for (var i = 0, len = callbacks.length; i < len; i++) {
                callbacks[i].apply(null, args)
            }
        }
    }
    /** off 方法接受事件名称和当初注册的回调函数作参数，在 Event 对象的 _cbs 属性中删除对应的回调函数。*/
    off(event, fn) {
        this._cbs = this._cbs || {}
        // all
        if (!arguments.length) {
            this._cbs = {}
            return
        }
        var callbacks = this._cbs[event]
        if (!callbacks) return
        // remove all handlers
        if (arguments.length === 1) {
            delete this._cbs[event]
            return
        }
        // remove specific handler
        var cb
        for (var i = 0, len = callbacks.length; i < len; i++) {
            cb = callbacks[i]
            if (cb === fn || cb.fn === fn) {
                callbacks.splice(i, 1)
                break
            }
        }
        return
    }
}

const myEvent = new Event();
export default myEvent;
```