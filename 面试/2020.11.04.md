

401 403 各代表什么 


服务端  和 客户端差异 cookie


node  怎么判断有没有溢出


浏览器 怎么看 内存溢出

linx 查看本地路径  777 sudo  chmod +r



http2.0 和 http1.1 多路复用和 keep-alive



## 手写翻转链表

```JS
//节点构造函数
function Node(val){
    this.val = val
    this.next = null
}

var reverseList = function (head) {
    let pre = null
    while (head) {
        next = head.next
        head.next = pre
        pre = head
        head = next
    }
    return pre
};

```

![](https://tva1.sinaimg.cn/large/0081Kckwgy1gkdzgsv6opj30sc0gqtbp.jpg)

## 手写单例



```js
function Single(fn){
  var result;
  return function(){
    return result || (result = fn.apply(this, arguments))
  }
}


```

## 平衡二叉树

```JS
//重复遍历了
function IsBalanced_Solution(pRoot) {
  if (pRoot == null) return true;
  let leftLen = TreeDepth(pRoot.left);
  let rightLen = TreeDepth(pRoot.right);
  return Math.abs(rightLen - leftLen) <= 1 && IsBalanced_Solution(pRoot.left) && IsBalanced_Solution(pRoot.right);
}
function TreeDepth(pRoot) {
  if (pRoot == null) return 0;
  let leftLen = TreeDepth(pRoot.left);
  let rightLen = TreeDepth(pRoot.right);
  return Math.max(leftLen, rightLen) + 1;
}
/* function TreeNode(x) {
    this.val = x;
    this.left = null;
    this.right = null;
} */

//同时判断
function IsBalanced_Solution(pRoot)
{
    // write code here
    return TreeDepth(pRoot) !==-1;
}
function TreeDepth(pRoot){
    if(pRoot === null) return 0;
    var left = TreeDepth(pRoot.left);
    if(left === -1)return -1;
    var right = TreeDepth(pRoot.right);
    if(right === -1)return -1;
    return Math.abs(left - right) > 1 ? -1: Math.max(left,right) + 1;
}

```


## 寻找链表第k 个节点


