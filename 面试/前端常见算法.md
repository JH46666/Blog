1. 冒泡算法

``` js
  function bubbleSort(arr) {
      var i = 0;
      var j = 9;

      for (i = 1; i < arr.length; i++) {
          for (j = 0; j < arr.length; j++) {
              var temp = 0;

              if (arr[j] > arr[i]) {
                  temp = arr[j];
                  arr[j] = arr[i];
                  arr[i] = temp
              }
          }
      }
      return arr;
  }
```

2. 翻转字符串

  思路一: 反向遍历字符串

``` js
function reverseString(str) {
    var tmp = '';
    for (var i = str.length - 1; i >= 0; i--)
        tmp += str[i];
    return tmp
}
```

转化成 array 操作

``` js
function reverseString(str) {
    var arr = str.split("");
    var i = 0,
        j = arr.length - 1;
    while (i < j) {
        tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
        i++;
        j--;
    }
    return arr.join("");
}
```

3. 生成指定长度随机字符串

4. 随机生成验证码

``` js
  let code = ""
  const arr = new Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);
  const codeLength = 6;
  for (var i = 0; i < codeLength; i++) {
      var index = Math.floor(Math.random() * 10);
      console.log('index', index)
      code += arr[index]
  }

  return code
```

5. 数组去重

``` js
function unique(arr) {
    var obj = {}
    var result = []
    for (var i in arr) {
        if (!obj[arr[i]]) {
            obj[arr[i]] = true;
            result.push(arr[i]);
        }
    }
    return result;
}
```

6. 数组中最大差值

``` js
function getMaxProfit(arr) {
    var min = arr[0];
    var max = arr[0];

    for (var i = 0; i < arr.length; i++) {
        if (arr[i] < min) min = arr[i];
        if (arr[i] > max) max = arr[i]
    }
    return max - min

}
getMaxProfit([2, 3, 10, 11, 23, 34])
```

7. 生成斐波那些数列

``` js
function getfib(n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    if (n > 1) return getfib(n - 1) + getfib(n - 2);
}

function fibo(len) {
    var fibo = [];
    for (var i = 0; i < len; i++) {
        fibo.push(getfib(i));
    }
    return fibo;
}

`
```

8. 二分查找法

``` js
function binary_search(arr, key) {
    var low = 0,
        high = arr.length - 1;
    while (low <= high) {
        var mid = parseInt((high + low) / 2);
        if (key == arr[mid]) {
            return mid;
        } else if (key > arr[mid]) {
            low = mid + 1;
        } else if (key < arr[mid]) {
            high = mid - 1;
        }
    }
    return -1;

// 递归

function binary_search2(arr, low, high, key) {
  if(low > high) return -1;
  var mid = parseInt((low + high)/2);
  if(key == arr[mid]) {
    return mid;
  } else if(key > arr[mid]) {
    return binary_search2(arr, mid+1, high, key);
  } else if(key < arr[mid]) {
    return binary_search2(arr, low, mid-1, key);
  }
}

```

9. 实现一个函数, 判断输入是不是回文字符串

```js


```

10. 斐波那契

```js
let fib = function (num) {
  return num <= 1 ? 1 : fib(num - 1) + fib(num - 2);
};

```

尾递归调用优化

```js
let fib = function(num,num1=1,num2=1){
   return  num <= 1 ? num2 : fib(num-1,num2,num1+num2)
}
// fib(5) => 8

```

永远只有一个调用记录, 调用函数产生一个调用记录, 最后一步操作 return 把当前函数的计算结果当做参数传递给了下一个自身调用.

11. 判断是不是回文字符串

```js

function isPlalindrome(input) {
  if (typeof input !== 'string') return false;
  return input.split('').reverse().join('') === input;
}

```

```js
// 不使用 api
function isPlalindrome(input) {
  if (typeof input !== 'string') return false;
  let i = 0, j = input.length - 1
  while(i < j) {
      if(input.charAt(i) !== input.charAt(j)) return false
      i ++
      j --
  }
  return true
}

```

12. 不含重复字符串的最长子串的长度

```js
// 解法一: 维护数组:

// 使用一个数组来维护滑动窗口

// 遍历字符串, 判断字符串是否在滑动窗口数组里

* 不在则 push 进数组
* 在则删除滑动窗口数组里相同字符及相同字符前的字符，然后将当前字符 push 进数组
* 然后将 max 更新为当前最长子串的长度

var lengthOfLongestSubstring = function(s) {
    let arr = [], max = 0
    for(let i = 0; i < s.length; i++) {
        let index = arr.indexOf(s[i])
        if(index !== -1) {
            arr.splice(0, index+1);
        }
        arr.push(s.charAt(i))
        //arr.push(s[i])
        max = Math.max(arr.length, max);
    }
    return max
};

console.log(lengthOfLongestSubstring("abcabcbb"));
```


1. 有效的括号

```js
var isValid = function(s) {
    let map = {
        '{': '}',
        '(': ')',
        '[': ']'
    }
    let stack = []
    for(let i = 0; i < s.length ; i++) {
        if(map[s[i]]) {
            stack.push(s[i])
        } else if(s[i] !== map[stack.pop()]){
            return false
        }
    }
    return stack.length === 0
}


```