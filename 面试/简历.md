面试

1. 暴露自己的优势

精心准备---结构化：

1. 介绍做的业务
2. 讲技术产出
3. 技术成长
4，技术贡献

几个重要的业务和业务的产出

这个框架有：

  1. 多少项目在使用框架---业务的产出
  2. 对业务的深入理解 做的价值、 业务（产品） 指出指标

3.业务的复杂度

  1. 解决多端之间的业务共享
  2. 遇到的挑战

3.解决方案
  
  1. 低端设备适配到哪一步。
  2. 保证页面的加载

主要缺陷---优化了哪些
结构化表达
1.第一部分 多少部分 给预期
2.重点先行 讲产出 讲框架 讲性能优化

回答技术问题 和 原理相关

深度和广度

mpa是怎么实现的： 讲原理

工作中遇到的坑

表明实践过

面试完---算法

1.跟面试官的互动

2.时间复杂度

-------------------------------------------

1.交叉面是什么形式--前端
2.几道算法---手写和算法
3.多写题目

我叫沈君鸿，现在在腾讯TAPD就任前端岗位，主要负责的业务有，富文本编辑器部分，甘特图还有缺陷，需求的性能优化。

我参与的部分还有前后分离的打包优化这块

首先就是需求和缺陷列表的性能优化部分
 现有的老代码是php实现的，所以他们20年就在升级成前后分离的开发方式，当好我进去了，所以我一同建设了
首先就是提升lighthouse的分数

1. 大计算量的逻辑走webworker 将需求树的一些属性、权限计算的部分放到 webwork 里面
2. 精简api请求，将api都收敛起来
3. 组件进行按需加载，复用组件，资源大小的优化

旧版的需求 缺陷列表 只能支持到需求树200，而我们现在做的事情就是双向懒加载的方式实现需求树突破200的性能，

针对底层的 table 组件进行改造，原本是用element的table组件生成

接口的聚合
缓存方面

提升了页面加载的速度

甘特图 部分就是 canvas是重点

针对canvas的一些优化

1.只处理可视区域的内的甘特条和关系线

2.处理计算逻辑

3.我们将这里面的一些鼠标操作都用代理的形式统一管理起来

```javascript
this.ganttChart.mouseEvents
```

在运用自己写的requestAnimation 去做性能优化的提升，解决重复拖动的时候，重复渲染造成的卡顿

```javascript
/**
 * requestAnimationFrame polyfill
 */
(function () {
  let lastTime = 0;
  const vendors = ['ms', 'moz', 'webkit', 'o'];
  for (let x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[`${vendors[x]}RequestAnimationFrame`];
    window.cancelAnimationFrame =
      window[`${vendors[x]}CancelAnimationFrame`]
      || window[`${vendors[x]}CancelRequestAnimationFrame`];
  }

  if (!window.requestAnimationFrame)
    window.requestAnimationFrame = function (callback) {
      const currTime = new DatePolyfill().getTime();
      const timeToCall = Math.max(0, 16 - (currTime - lastTime));
      const id = window.setTimeout(() => {
        callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };

  if (!window.cancelAnimationFrame)
    window.cancelAnimationFrame = function (id) {
      clearTimeout(id);
    };

  class DatePolyfill {
    constructor(date) {
      if (!date) {
        return new Date();
      }
      const { userAgent } = window.navigator;
      if (userAgent.includes('Safari') || userAgent.includes('wxwork')) {
        if (typeof date === 'string') {
          date = date.replace(/-/g, '/');
          return new Date(date);
        }
        return new Date(date);
      }
      return new Date(date);
    }
  }

  window.DatePolyfill = DatePolyfill;
})();

```

主要的难点还是在在于处理左边表格变动的时候，右边甘特图的自适应宽高情况

```javascript
      window.requestAnimationFrame(() => {
        const elClientRect = getBoundingClientRect(this.$el);
        let { x, y } = elClientRect;
        const { width } = elClientRect;
        x = Math.max(x, 0);
        y = Math.max(y, 0);
        x += document.body.scrollLeft;
        y += document.body.scrollTop;
        this.width = width;
        this.tableWidth = parseInt(this.width * this.splitPecent);
        this.ganttWidth = this.width - this.tableWidth;
        if (this.fixedHeight) {
          this.height = this.fixedHeight;
          this.contentHeight = this.fixedHeight;
        } else {
          this.height = Math.min(
            window.innerHeight - y - this.marginBottom,
            this.flattenList.length * this.rowHeight + 60 + 9
          );
          this.contentHeight = window.innerHeight - y - this.marginBottom;
        }
        this.ganttChart.update({
          width: this.ganttWidth,
          height: this.height,
        });
        this.$emit(
          'sizeUpate',
          this.flattenList.length,
          this.flattenList.length * this.rowHeight + 60
        );
      });
```

富文本编辑器  主要有两种方案：提供挂载点和自定义组件：

1. 自定义组件 （插入思维导图、腾讯文档、插入自定义对象、插入代码块）
    在编辑器里面将自定义的按钮绑定好通信逻辑，在业务层面去监听调用的部分。这一部分主要是依托于编辑器的能力

2.挂载点 亮点 也是难点

// 难点  怎么能够同步更新版本 如果我们自己拉下来之后

```javascript
import { get, pick } from 'lodash-es';
import api from '@/api';
import { MessageBox } from 'element-ui';
class OpenAppEventBridge {
  constructor() {
    this.messageHandler = this.messageHandler.bind(this);

    if (window.addEventListener) {
      window.addEventListener('message', this.messageHandler);
    } else {
      window.attachEvent('onmessage', this.messageHandler);
    }

    this.store = {};
  }

  messageHandler(e) {
    const { data = {}, origin, source } = e;

    const { code } = data;
    // console.debug(data);

    if (!code) {
      return;
    }

    this.broadcast(data);
  }

  findProxy({ entranceId, appID }) {
    return Object.values(this.store).find(
      proxy => proxy && proxy.entranceId === entranceId && proxy.appID === appID
    );
  }

  broadcast(data) {
    const { code, event, params, id } = data;
    Object.entries(this.store).forEach(([key, proxy]) => {
      if (key === code) {
        proxy.emit(event, { params, code, id }, this);
      }
    });
  }

  /**
   * 主要目的就是为了绑定相应的iframe对象
   */
  registerApp(params) {
    const proxy = new Proxy(params);

    this.store[proxy.code] = proxy;

    return proxy;
  }

  updateAppCode(preCode, newCode) {
    const appProxy = this.store[preCode];
    appProxy.code = newCode;
    this.store[newCode] = appProxy;
    this.store[preCode] = null;
  }

  destroyApp(code) {
    this.store[code] = null;
  }
}

class Proxy {
  constructor({
    code,
    appID,
    entranceParams,
    iframe,
    vm,
    workspaceId,
    entityId,
    entityType,
    entranceId,
  }) {
    this.code = code;
    this.iframe = iframe;
    this.appID = appID;
    this.workspaceId = workspaceId;
    this.entranceParams = entranceParams;
    this.vm = vm;
    this.entityId = entityId;
    this.entityType = entityType;
    this.entranceId = entranceId;

    this.queue = [];
  }

  on(event, callback) {
    this.queue.push({ event, callback });
    return this;
  }

  emit(event, { params, code, id }, controller) {
    this.queue.forEach(async item => {
      if (event === item.event) {
        const result = await item.callback.call(
          this.vm,
          {
            params,
            proxy: this,
            code,
            id,
          },
          controller
        );

        this.send({
          params: result,
          id,
        });
      }
    });
  }

  send({ event = '', params, id }) {
    console.log(event, params, id);
    const message = {
      code: this.code,
      event,
      params,
      id,
    };
    const { iframe } = this;
    iframe.contentWindow.postMessage(message, '*');
  }
}

export default function (Vue) {
  const controller = new OpenAppEventBridge();

  // eslint-disable-next-line no-param-reassign
  Vue.prototype.$registerApp = function (params) {
    const vm = this;

    // register open app proxy and listen common event for vue components
    const proxy = controller
      .registerApp({
        ...params,
        vm,
      })
      .on('showFlash', message)
      .on('generateCode', refreshToken)
      .on('getEntranceData', getEntranceData)
      .on('openObjURL', openObjURL)
      .on('openBkURL', openBkURLPage)
      .on('showConfirm', showConfirm)
      .on('handlerInvoke', handlerInvoke)
      .on('getUserListByKeyWords', getUserListByKeyWords)
      .on('getWorkspaceMemberList', getWorkspaceMemberList)
      .on('getAllRelateMember', getAllRelateMember)
      .on('syncPageEvent', syncPageEvent)
      .on('showDialog', showDialog)
      .on('closeConfirm', closeConfirmCallBack);

    // remove the proxy when vue components destroyed
    vm.$on('hook:beforeDestroy', () => {
      controller.destroyApp(proxy.code);
    });

    return proxy;
  };
  // Vue.prototype.$listenOpenApp = function () {};
}

/* event handle begin */

function message({ params }) {
  const { msg } = params;
  const message = msg.trim();
  message && this.$message(msg);
}

function closeConfirmCallBack({ params }) {
  const msg = get(params, 'params.msg', '').trim();
  message && this.$message(msg);
}

/**
 * @todo 历史原因已经不能够将这个code作为通信凭证的问题解决
 * @description 刷新code;
 */
async function refreshToken({ proxy }, controller) {
  const vm = this;
  const { currentWorkspaceId } = vm;

  const refreshCode = await api.open.generateCode({
    workspaceId: currentWorkspaceId,
    appID: proxy.appID,
  });

  // 历史代码的兼容，如果用的是JS-sdk不需要
  proxy.send({
    event: 'syncCode',
    params: { code: refreshCode },
  });

  controller.updateAppCode(proxy.code, refreshCode);
  return refreshCode;
}

/**
 * @description 同一个应用的不同挂载点通信
 */
function syncPageEvent({ params, proxy }, controller) {
  const { entranceId, data } = params;

  const targetProxy = controller.findProxy({
    appID: proxy.appID,
    entranceId,
  });

  if (targetProxy) {
    targetProxy.send({
      event: 'syncPageEvent',
      params: {
        data,
      },
    });
  }
}

/**
 * @description 获取挂在点信息
 */
function getEntranceData({ proxy }) {
  return pick(
    proxy,
    'entityId',
    'entityType',
    'workspaceId',
    'appId',
    'code',
    'entranceId'
  );
}

/**
 * @description 打开3大对象页面
 */
function openObjURL({ params, proxy }) {
  const { entityType, entityId } = params;
  const { workspaceId } = proxy;

  let url = '';

  // @TODO: 待确认跳转的链接地址
  switch (entityType) {
    case 'story':
      url = `/${workspaceId}/prong/stories/view/${entityId}`;
      break;
    case 'bug':
      url = `/${workspaceId}/bugtrace/bugs/view?bug_id=${entityId}`;
      break;
    case 'task':
      url = `/${workspaceId}/prong/tasks/view/${entityId}`;
      break;
  }

  url && window.open(url, '_blank');
}

/**
 * @description 打开 app_for_project 挂载点 跟 应用设置页面
 **/
function openBkURLPage({ params: options, proxy: data }) {
  const entityId = options.entityId || 'app_for_project';
  const url = `/${this.workspaceId + entityId + data.appId}#${options.url}`;
  if (url) window.open(url, '_blank');
}

async function showConfirm({ params, proxy }) {
  return await MessageBox.confirm(params.content, '', {
    dangerouslyUseHTMLString: proxy.code === 'code_review', // 老旧逻辑的白名单
  }).then(() => {
    proxy.send({
      event: 'confirmYes',
      params: { data: params.data },
    });
  });
}

/**
 * Api 错误的事件，不公开也不推荐添加 ；
 */
async function getUserListByKeyWords({ params, proxy }) {
  const result = await api.open.getUsers({
    workspaceId: params.workspace_id,
    keyword: params.key_word,
  });

  const response = {
    data: result.data.data,
    keyword: params.key_word,
  };

  proxy.send({
    event: 'userChooserFetchFinish',
    params: response,
  });

  return response;
}

async function handlerInvoke({ params, proxy }) {
  const { workspaceId, appID } = proxy;
  const { handler } = params;

  const res = await api.open.handleInvoke({
    workspaceId,
    appID,
    handler,
    params: params.params,
  });

  const invokeData = get(res, 'data.data');

  return invokeData ? invokeData : res;
}

async function getWorkspaceMemberList() {
  return {};
}

async function getAllRelateMember({ proxy }) {
  proxy.send({ event: 'getAllRelateMemberFinish', params: [] });
  return {};
}

function showDialog({ params, proxy }) {
  this.$openAppDialog({
    name: params.title,
    url: params.url,
    entranceId: 'open-app-dialog',
    height: params.height,
    appID: proxy.appID,
  });
}
```

故事墙拖拽

tapd 3的一些顶层设计

tapd3 复用fe项目的架构设计

工作经历
建议以项目纬度介绍自己，突出亮点。由项目来体现你的成长变化   表态度/展望 针对岗位，表达自己的态度，展现你的决心

忌
--

1. 想到什么说什么
 三言两语的解释
2。模糊不清的形容词
    如很好的优化了xxx

面试过程策略：

1. 背景  目标

2. 行动 结果

着重呈现
    如何通过技术一步步解决问题（亮点 痛点）

我在编辑器里面就是1号开发位啊

## 1. aftership 25号一面 26号vp面 27号hr面

## 2. 这个什么科技 27号  16:30  

## 乐信 4月28号 11:00 一面过 5月6号 11：00 二面过 5月9日14：00 三面过

## 奇安信 4月28号 15:00 一面过

## 百丽 4月29号 11:00 x

## 知乎 4月29号 14：00 x

## 迅雷 5月5号 17点 x

## 萌时科技 5月6号 20:00- 21:00 x

## 店匠	5月07日星期六10点00分 一面过

## 极简钱包  5月07号 15：00 x

## akulaku 5月9号 17:00 一面过 5月13号 二面过

## oppo 5月9号 10：00 x

## lazada 5月10日 10点30分

## 喜马拉雅 5月10日 15点00分 一面过 5月12号 16：30 二面过

## 迅雷 5月11日 19：00 x

## ambergroup-io 5月10日 16点00分 x

## 快影 5月13号 19:00 x

## 喜茶 5月13号 10点30分 x

## ones 笔试题 5月16号

## xmind 笔试题 5月16号 x

## 华为 笔试题

## 极狐 笔试题

## 字节 5月18号左右

## 虾皮 5月19号左右

## 微众 x

## 平安 x

## 京东 x

## 顺丰 x
