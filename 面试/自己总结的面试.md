最新的ECMAScript 标准定义了8 种数据类型:

7 种原始类型: Boolean. Null. Undefined. Number. BigInt. String. Symbol.
和Object.

FMP 值采集, 避免业务代码嵌入埋点逻辑, 通过 MutationObserver API 监听 dom 变化实现无手动埋点采集

babel-plugin-try-catch-auto 插件, 实现手动 try-catch 捕获运行时错误

css 代码采用 BEM + 原子 css 命名规范, 规范化开发

线上项目安全部门提出存在 csrf 攻击漏洞, 通过规范请求方式及使用 cookie 参数作为唯一标识 token, 验证请求来源, 完成漏洞修复

在性能优化上, 通过多种方式减少首屏时间, 包括使用 dns-prefetch 预解析 cdn, 充分应用了 react 的 state 批处理/purecomponent/memo 等功能减少不必要的调羹行

<https://juejin.im/user/2963939078450637>

某某 sdk + typescript + rollup + FCP/FMP
技术能力

1. 团队中技术用不上?? 创造条件 需找能用上点

1. 函数式编程 typescript 测试, 掌握一门后端语言
1. node docker k8s

new vue({})  v8 快属性  想到这个的对比 o = object.create() 和 o = {}

词法 => 语法 => ast => 字节码 => ao vo go => 收集代码信息  => 优化字节码 生成机器码

1. 性能指标 要求不高  
1. css bem 原子 矩阵 next houdouni  小程序和周边框架的原理

webpack 5 system + 通信 + 主服务

面试中遇到的大部分人的知识点，技能都差不多, 所以我们的基础一定要都记得全而且．
我们要在第一时间吸引面试官. 就是要有亮点,针对你的项目中运用到的技术栈,要比别人高大上，看看　ｒｅａｃｔ　ｎｏｄｅ　ｗｅｂｐａｃｋ　ｓｓｒ　能不能都用上去．自己创造条件．
还有能拉开距离的，还是你对框架的理解程度．　所以要多看框架源码，看能不能将现在一些常见的框架（ｑｉａｎｋｕｎ），自己实现一遍，反正就是在　ｇｉｔｈｕｂ，上面最好能有　ｓｔａｒ　．
还有就是　你在团队中的角色，是不是能够　ｈｏｌｄ　住新技术．并为团队带来工效的提升．

针对 webpack 相关的知识

正对 微前端 的相关知识

针对 react 相关的工具链 我要做到常见的原理应该知晓

immutable.js 原理 及 优缺点

redux 和 mobx 的区别与优缺点

针对 vue 相关的工具链 我要做到常见的原理应该知晓

vue-router

vuex

## vue 与 react 有什么不同

先说相似之处：

1. 使用 virtual Dom
2. 提供了响应式（reactive）和组件化（component）的视图组件
3. 将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库

不同之处：

1. react 有比vue 更好的生态系统
2. 在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。使用 PureComponent 和 shouldComponentUpdate 时，需要保证该组件的整个子树的渲染输出都是由该组件的 props 所决定的。

而在 vue 中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重新渲染。

jsx vs templates

jsx的优势
在react 中 一切都是js

1. 使用临时变量、js自带的流程控制、以及直接引用当前 js 作用域的值
2. 开发工具对jsx的支持比vue更先进（linting， 类型检查， 编辑器的自动完成）

vue的优势：
我们也可以写 babel-jsx-loader
vue 鼓励写近似常规 html 的模板， 更像经典的 web

react

我们可以把组件区分为两类：一类是偏视图表现的 (presentational)，一类则是偏逻辑的 (logical)。我们推荐在前者中使用模板，在后者中使用 JSX 或渲染函数。

问过我有没有自己手写过 loader ， 讲出在 mpvue 里面 添加过 filter

首先正则匹配 | ， 然后全前面的值 作为 后面方法的参数， 在返回回去给模板，

数据状态管理
 Vuex 改变 store 的方式支持提交一个 mutation， 而redux并不支持，mutation 类似于事件发布、订阅系统： 每个mutation 都通过一个字符串来表示时间类型（type）， 并通过一个回调函数 handler 来进行对应的数据修改。 另一个中，store 是直接注入组件实例中的， 因此用起来更加方便； 而 redux 需要通过 connect 方法把 prop 和 dispatch 注入组件。

## 新的微前端方式

模块联邦背后的原理非常简单：宿主系统通过配置名称来引用远程模块，同时在编译阶段宿主系统是不需要了解远程模块的，仅仅在运行时通过加载远程模块的入口文件来实现。

模块联邦的使用方式

```js
const HtmlWebpackPlugin = require("html-webpack-plugin");
const ModuleFederationPlugin = require("webpack/lib/container/ModuleFederationPlugin");

module.exports = {
  // other webpack configs...
  plugins: [
    new ModuleFederationPlugin({
      name: "app_one_remote",
      remotes: {
        app_two: "app_two_remote",
        app_three: "app_three_remote"
      },
      exposes: {
        AppContainer: "./src/App"
      },
      shared: ["react", "react-dom", "react-router-dom"]
    }),
    new HtmlWebpackPlugin({
      template: "./public/index.html",
      chunks: ["main"]
    })
  ]
};
```

JavaScript 为什么不做多线程处理呢， 还能更加充分利用cpu

我们设想一下： 如果一个线程去更新某个DOM元素，而另一个线程去删除这个 DOM 元素，那么浏览器该执行哪个操作呢？

为了避免复杂的多线程机制， JavaScript 从设计之处就选择了单线程标准， 而且未来也不会发生变化。

Web Worker不是允许 JavaScript 来创建多线程吗？

这个是没错的，但是要注意的是，Web Worker创建的子线程是不能操作DOM的，操作DOM的任务需要交给主线程来执行，而且子线程完全受到主线程的控制，因此Web Worker的提出也并没有改变JavaScript单线程的本质。

## Event Loops 的作用

在JavaScript引擎的主线程上，会包含一个执行栈，按照栈后进先出的顺序处理栈中的任务。

<https://www.jianshu.com/p/be5bfc1f1ae4>

首先执行同步代码，即script脚本，这属于宏任务
当执行完所有同步代码后，执行栈清空
从微任务队列中逐个取出回调任务，放入执行栈中执行，直至所有微任务执行完成。注意：如果在执行微任务的过程中，产生了新的微任务，那么这个微任务会加入到队列的末尾，同样会在这个周期内被执行。
当执行完所有微任务后，如果有必要会开始渲染页面
开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数。

![](https://tva1.sinaimg.cn/large/0081Kckwgy1gkmlcq4403j30kk0ladg8.jpg)
1、执行全局的script代码，第1行代码

此时Stack Queue：[console]

Macrotask Queue：[]，

Microtask Queue：[]

此阶段输出1。

2、执行到2-7行setTimeout代码，此时会将setTimeout的回调推入Macrotask Queue

此时Stack Queue：[setTimeout本身]

Macrotask Queue：[setTimeout callback]，

Microtask Queue：[]

此阶段没有输出。

3、执行8-13行Promise代码，在Promise构造函数内部的代码实际是同步代码，直到遇到resolve或者reject，才会触发异步的回调。

而Promise的异步任务回调会被推入到Microtask Queue。

此时Stack Queue：[Promise内的console]，

Macrotask Queue：[setTimeout callback1]，

Microtask Queue：[Promise callback]

此阶段输出4。

4、执行14-16行setTimeout代码，与上一个setTimeout一样，会被推入到Macrotask Queue

此时Stack Queue：[setTimeout本身]，

Macrotask Queue：[setTimeout callback1，setTimeout callback2]，

Microtask Queue：[Promise callback]

此阶段没有输出。

5、执行第17行代码，实际是同步代码，会进入到执行栈中。

此时Stack Queue：[console]，

Macrotask Queue：[setTimeout callback1，setTimeout callback2]，

Microtask Queue：[Promise callback1]

此阶段输出7。

6、至此第一轮的宏任务执行完成，开始从微任务队列中取出任务执行，直至微任务队列为空。

第10行代码resolve(5)执行后，会进入到then()方法内部，执行第12行代码。

此时Stack Queue：[Promise callback1]，

Macrotask Queue：[setTimeout callback1，setTimeout callback2]，

Microtask Queue：[]

此阶段输出5。

7、至此微任务队列清空，第一轮微任务也执行完成，开始下一轮event loop

8、执行setTimeout宏任务的回调，并将其推入到执行栈中。

此时Stack Queue：[setTimeout callback1]，

Macrotask Queue：[setTimeout callback2]，

Microtask Queue：[]

此阶段输出2。

但是在执行到第4行代码时，又生成了一个新的Promise，会将其推入到Microtask Queue中。

Microtask Queue：[promise callback2]。

9、宏任务执行完成后，开始从微任务队列中取出任务执行，即第5行代码

此时Stack Queue：[promise callback2]，

Macrotask Queue：[setTimeout callback2]，

Microtask Queue：[]

此阶段输出3。

10、第二轮任务轮询结束，开始第三轮event loop

11、执行第二个setTimeout任务回调，即第15行代码。

此时Stack Queue：[setTimeout callback2]，

Macrotask Queue：[]，

Microtask Queue：[]

此阶段输出6。

12、至此全部执行完成，Stack Queue，Macrotask Queue，Microtask Queue均为空。

关于宏任务和微任务中的setTimeout和Promise，我们再增加一些更加容易让人理解的解释。

setTimeout的作用是等待给定的时间后为它的回调产生一个新的宏任务，这个宏任务将在下一轮循环中执行，而Promise的回调是在当前轮循环中产生，并推入到当前循环的微任务队列中。

这就是为什么打印'2'在'5'之后。因为打印'5'是第一轮微任务里做的事情，而打印'2'是在第二轮的宏任务里做的事情。

setTimeout的作用是等待给定的时间后为它的回调产生一个新的宏任务，这个宏任务将在下一轮循环中执行，而Promise的回调是在当前轮循环中产生，并推入到当前循环的微任务队列中。

进行单元测试

1. 创建一些初始数据；
2. 对外部依赖进行mock；
3. 最小粒度的执行要测试的测试方法；
4. 对结果做断言；

![Unit测试](https://tva1.sinaimg.cn/large/0081Kckwgy1gkxncfpkoqj30u007wq49.jpg)

个人成长很重要，同时想要取得好的结果得到晋升，一定要将个人的成长和团队的成长绑定起来。
找到那个个人和团队双赢的点去发力，可以得到事半功倍的效果。

1. 如果你的团队还没有内部的分享会，尝试着自己去组织一个定期的内部分享会；
2. 从现在开始做 CR 和单测，用自己来影响团队；
3. 尝试着在团队中建立契合团队的工程师文化

## 为什么vue 不用做渲染

在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。你可以理解为每一个组件都已经自动获得了 **shouldComponentUpdate**，并且没有上述的子树问题限制。
