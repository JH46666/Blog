## 延时问题的链式调用

```JS
class Queue {
    constructor() {
        this.queue = []
    }
    add(timeout, callback) {
        this.queue.push({
            timeout,
            callback
        })
        return this
    }
    // promise方法
    start() {
        // Promise 链式调用
        var promise = new Promise((resolve)=>{
            resolve()
        })
        for(let i=0;i<this.queue.length;i++){ // 注意作用域内 存在异步任务变量的let
            let {timeout, callback} = this.queue[i]
            promise = promise.then(()=>{
                return new Promise((resolve)=>{
                    setTimeout(()=>{
                        callback()
                        resolve()
                    }, timeout)
                })
            })
        }
        this.queue = null
    }
}
// https://blog.csdn.net/womuz/article/details/108340544
```

## 实现eventBus

```JS
const eventBus = () => {
  subs = new Map();
  return {
    subs,
       /**
      * 注册事件
      * @param {string} type 事件类型
      * @param {Function} callback 回调函数 
      */
    $on(type, callback){
      const subStack = subs.get(type);
      const value = subStack && subStack.push(callback);
      if(!value){
        subs.set(type, [callback])
      }
    },
    /**
      * 触发事件
      * @param {string} type 事件类型
      * @param {Any} payload 传递的参数
      */
    $emit (type, ...payload) {
      (subs.get(type) || []).forEach(fn => { fn(...payload) });
      (subs.get('*') || []).forEach(fn => { fn(...payload) }); /* 所有事件类型都执行 */
    },
    /**
      * 注销事件
      * @param {string} type 事件类型
      * @param {Function} callback 回调函数 
      */
    $off(type, callback) {
      const sub = subs.get(type);
      if (sub) {
        sub.splice(sub.indexOf(callback) >>> 0, 1);
      }
    }
  }
}
// 可以使用Map自带的clear清空EventBus
emitter.subs.clear() // 清空EventBus

```

## qiankun遇到的问题

## qiankun 怎么去管理包

## 节流和防抖

## 性能优化相关的

分为三步： 网络资源的加载，浏览器内代码执行和DOM渲染
优化方向：

**1. 缩短请求耗时**
**2. 减少重排重绘**
**3.改善JS性能**

**一. 缩短请求耗时**
**1：优化打包资源**
总体原则：减少或延迟模块的应用，以减少网络符合

常用工具：

webpack
webpack-bundle-analyzer可视化分析工具

常用方法：

* 减小体积：减少非必要的import;压缩JS代码;配置服务器gzip等;使用WebP图片;
* 按需加载：可根据“路由”、“是否可见”按需加载JS代码，减少初次加载JS体积。比如可以使用import()进行代码分割，按需加载;
* 分开打包：利用浏览器缓存机制，依据模块更新频率分层打包。
其他方法：雪碧图：每个HTTP/1.1请求都是独立的TCP连接，最大6个并发，所以合并图片资源可以优化加载速度。HTTP/2已经不需要这么做了。

**2. CDN加速**
总体原则： 通过分布式的边缘网络节点，缩短资源到终端用户的访问延迟。

常用工具：

Cloudflare
AWS CloudFront
Aliyun CDN

常用方法：加速图片、视频等大体积文件

**3. 更高版本的HTTP**
总体原则：使用高版本HTTP提升性能。

常用工具：HTTP/2

HTTP/2较HTTP/1.1最大的改进在于：

多路复用：单一TCP连接，多HTTP请求;
头部压缩：减少HTTP头体积;
请求优先级：优先获取重要的数据;
服务端推送：主动推送CSS等静态资源。
其他方法：HTTP/3

HTTP/3基于UDP，有很多方面的性能改进，如多路复用无队头阻塞，响应更快。感兴趣的同学可参考Wiki。

如果几个配置同时存在，则优先级为：Cache-Control > Expires > ETag > Last-Modified。

**4. 浏览器缓存**

总体原则：避免重复传输相同的数据，节省网络带宽，加速资源获取。

常用方法：

可以通过设置HTTP Header来控制缓存策略，一般有如下几种。

强缓存：

Expires：HTTP/1.0
Cache-Control：HTTP/1.1
协商缓存：

ETag + If-None-Match
Last-Modified + If-Modified-Since
拿ETag举例，如果浏览器给的If-None-Match值与服务端给的ETag值相等，服务器就直接返回304，从而避免重复传输数据。

接着就是从服务端拿到数据之后：
浏览器会从上到下执行上下文：这时候其实我们要做的事情就是减少重排跟重绘

**1. 减少渲染量**
总体原则：不渲染未展示的部分。

可以讲讲我做的双向懒加载
常用工具：

react-window
react-loadable
JS原生，如IntersectionObserver
框架提供，如React.lazy、react-intersection-observer
常用方法：

虚拟列表：只渲染可见区;
惰性加载：无限滚动;
按需加载：页面只在切换过去时才加载。

**2. 减少渲染次数**

总体思路：避免重复的渲染。

可以讲讲table表格的优化

这个体现在我通过代理的方式劫持了重复渲染的逻辑

常用工具：

lodash
JS或框架自带
常用方法：

防抖与节流;
对于React函数组件来说，合理使用副作用，拆分无关联的副作用;
对于React类组件来说，可以使用shouldComponentUpdate或使用PureComponent来优化渲染;
利用缓存，如React.memo;
使用requestAnimationFrame替代setInterval执行动画。

**三、改善JS性能**

因为浏览器是单线程异步模型，长时间的运算会阻塞渲染过程，所以改善复杂运算有助于改善前端的整体性能

1. 缓存复杂计算
总体思路：避免重复计算。

常用方法：对于React函数组件来说，可以使用useMemo缓存复杂计算值。

举例如下，memoizedValue需要经过复杂计算才能得到，此时就可以使用useMemo缓存，仅仅在输入参数发生变化时才重新计算，避免计算阻塞页面渲染，从而避免页面卡顿。

1. 缓存复杂计算
总体思路：避免重复计算。

常用方法：对于React函数组件来说，可以使用useMemo缓存复杂计算值。

举例如下，memoizedValue需要经过复杂计算才能得到，此时就可以使用useMemo缓存，仅仅在输入参数发生变化时才重新计算，避免计算阻塞页面渲染，从而避免页面卡顿。

// 讲讲我做的计算

2. Web Worker
总体原则：多线程思想。

常用方法：

Dedicated Workers，处理与UI无关的密集型数学计算：大数据集合排序、数据压缩、音视频处理;
Service Worker，服务端推送，或者PWA中配合CacheStorage在前端控制缓存资源;
Shared Worker，Tab间通信。
JS语言在设计之初就是单线程异步模型，好处是可以高效处理I/O操作，但坏处是无法利用多核CPU。

Web Worker会启动系统级别的线程，可进行多线程编程，发挥多核的性能。

## 委托和代理
