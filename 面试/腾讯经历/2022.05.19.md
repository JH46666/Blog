## 字节

```js
Promise.all((Promise.then(1), 2).then(v=> console.log(v)) // 输出1,2

Promise.all((Promise.then(1), 2, Promise.reject(3)).then(v=> console.log(v)) // 3

Promise.all((setTimeout()=>{console.log(1), 500}, 2, Promise.reject(3)).then(v=> console.log(v)) // 1,2,3


```

Promise.all的规则是这样的

```js
  Promise.all = function(arr){
    let index = 0, result = [];
    return new Promise((reslove, reject) => {
      arr.forEach((p, i)=> {
        Promise.resolve(p).then(val => {
          index++
          result[i] = val
          if(index === arr.length) {
            reslove(result)
          }
        }, err => {
          reject(err)
        })
      })
    })
  }

```

## 数字证书是个啥玩意

证书是一个文件，里面包含有目标网站的各种信息

例如：网站的域名，证书的有效期，签发机构等

其中最重要的是这两个：

1. 用于生成对称密钥的公钥
2.由上级证书签发的签名

证书文件的格式叫做 X.509，由 RFC5280 规范详细定义。存储上分为两种，一种叫做 DER，是二进制的，还有一种叫做 PEM，是基于 Base64 的。

关于 RSA 的公钥和私钥记住一点就行：**我们可以使用算法生成一对钥匙，他们满足一个性质：公钥加密的私钥可以解开，私钥加密的公钥可以解开。**

证书，顾名思义，是用来证明自己身份的。因为发送证书的时候是明文的（这一步也没法加密），所以证书内容是可以被中间设备篡改的。

怎么验证证书内容是不是被中间设备篡改：**解决办法是采用「信任链」**

首先，有一批证书颁发机构（Certificate Authority，简称为 CA），由他们生成秘钥对，其中私钥保存好，公钥以证书的格式安装在我们的操作系统中，这就是 根证书。

我们的手机、电脑、电视机的操作系统中都预装了 CA 的根证书，他们是所有信任构建的基石。当然，我们也可以自己下载任意的根证书进行安装。

比如说，我们收到了服务器发过来的 C 证书，我们验证了 C 是由 B 签发的，然后又验证了 B 是由 A 签发的，而 A 在我们的系统中存在，那也就证明了 C 这个证书的有效性

-----------------------------------------------------------

得益于 RSA 的非对称性质，验证 A 是否签发了 B 证书很简单：

计算 B 的 hash 值（算法随便，比如 SHA1）
使用 A 的 私钥 对该 hash 进行加密，加密以后的内容叫做「签名（Signature）」
将该「签名」附在 B 证书中

## 为什么非对称加密比对称加密慢？

常见的对称加密算法有：AES、DES、3DES 所以你可以将对称加密简单理解为：一方通过密钥将信息加密后，把密文传给另一方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文。

非对称加密不同于对称加密，它有一对秘钥，一个称为公钥（publicKey） ，另一个称为私钥（privateKey），并且*只知道公钥是无法推算出私钥。

常见的非对称加密算法有：RSA、DSA、ECC 另外，这种算法还有一个特别神奇的功能，那就是通过公钥加密的内容，只有私钥才可以解开，而通过私钥加密的内容，只有公钥才可以解开。

公钥、私钥的用法：

第一种用法：公钥加密，私钥解密。---用于加解密

既然是加密，那肯定是不希望别人知道我的消息，所以只有我才能解密，所以可得出公钥负责加密，私钥负责解密；

第二种用法：私钥签名，公钥验签。---用于签名

既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出私钥负责签名，公钥负责验证。

这里提一点：签名 ≠ 加密，通俗点说加密就是你哪怕看到了不该看到的东西，也理解不了。而签名就是你做了任何事，都抵赖不了。

那为什么非对称加密比对称加密慢

这是因为对称加密主要的运算是位运算，速度非常快，如果使用硬件计算，速度会更快。以 AES 算法为例，如下图所示，其运算本质上来说就是位移和替换。

但是非对称加密计算一般都比较复杂，比如 RSA，它里面涉及到大数乘法、大数模等等运算。其加解密可以用下面的公式来表示：

## https 运用了那种加密

  答案是两种都用到了

1. 首先随机生成单次请求加密密钥(clientAesKey，长度为 16 位，可以用 26 个字母和数字组成))
2. RSA负责加密一个字符(clientAesKey)
3. AES负责用这个字符串(clientAesKey)、明文加密一个密文

----
4.解密时首先要用RSA获取这个字符串(clientAesKey)
5.然后用AES解密密文

[参考文献](https://cjting.me/2021/03/02/how-to-validate-tls-certificate)
