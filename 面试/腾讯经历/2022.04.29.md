```JS
function spredArr(arrs){
  const newArr = [];
  function dp(arrs){
    for(let arr of arrs){
      if(Array.isArray(arr)){
        dp(arr)
      } else {
        newArr.push(arr)
      }
    }
    return newArr
  }
  return dp(arrs)
}
const arr = [2,[3,[5]]];
console.log(spredArr(arr))
```

Array.from()
// for in for map reduce filter  some
//

## vue 平时用到的优化点

## vue新的api 包括3的优化点是什么

## 编辑器里面主要是做了啥

## 编辑器的难点 亮点

  我在这个编辑器里面主要是提供了一个挂载点的功能：
  让第三方应用能够使用

  编辑器遇到的难点

## 表格做的优化

  我用的是element 的table 组件 ，因为用户在进来的时候其实更多的是去看，而不是去使用，所以我们在组件层面做了懒加载的处理，比方说用户的table 有三列（开始时间、结束时间、处理人）时间控件，人民空间，我们会根据dom 的类型，通过代理的形式把时间或者人名的类型获取到再去挂载相对应的组件，进行替换（里面用到vnode.el）。

  还做了双向懒加载的优化：
    我们自定义了用户浏览器的宽高（getBroundClientWidth， height），在首屏进来的时候，因为这个需求树的高度我们是确定的，前端会去获取当前浏览器需要加载的对应的数据，比方说如果这个用户有200个需求树，根据用户的浏览器大小 我能获取这个父需求下的前50个子需求，我，等到他往下面滚动的时候，采取加载剩下的150个子需求。因为我们自己实现了滚动条。可以计算出用户的偏移量，能够知道他的滚动范围，能够计算出相对应应该加载的数据。

  ui控件 = 「100」； 大小 = 【100】；

  渲染层面： 每个组件会渲染10*10；现在只要渲染10；

## vue和react讲对比

## 为啥 react 要搞immutable

## react 的shouldcomponent是怎么实现的

## 怎么做技术选型，当初为啥选择tinymce

    1.我先是对比了下 TinyMce 跟其他家【quill、ueditor、kindeditor、wangeditor】的它具有一下特点

drat.js 和 slate 都是依赖react,uEditor 没有在维护了. powerpaste 算是一个亮点

1. 开源可商用
1. 插件丰富， 自动插件基本涵盖日常所需功能
1. 接口丰富，可拓展性强，有能力可以无限拓展功能
1. api文档很清晰

首先如果你的业务及其复杂，需要定制很多自定义功能，那么slate无疑是首选，但是前提是你要自己去实现view 层，并且有这个开发能力  

基于 DOM API 实现 selection、rang

## 多人实时协同编辑怎么做

调研对象： google docs， ckeditor 5， slate， quill
结论： 都用operation transformation，将操作转化为op，发送到协作服务，在转发给其他在线用户。

我觉得可以改进的部分：
1.增加实时协同的功能
 具体实现方案： 引入新的command机制，所有的变更都通过command完成，变更之后产生对应的op，包括backward 你想操作。

|  op格式   | JSON  |  DOM
|  ----  | ----  |
| {p:PATH, li:NEWVALUE}  | List Insert | 插入 Node
| {p:PATH, ld:OLDVALUE}  | List Delete | 删除 Node
| {p:PATH, oi:NEWVALUE}  | Object Insert | 增加 Element 属性
| {p:PATH, od:OLDVALUE}  | Object Delete | 删除 Element 属性

## 前后端分离的好处

1. 提供工作效率，分工更加明确。前端只关注前端的事，后台只关心后台的活，两者开发可以同时进行，在后台还没有时间提供接口的时候，前端可以先将数据写死或者调用本地的JSON文件即可，页面的增加和路由的修改也不必再去麻烦后台，开发更加灵活。

2.局部性能提升。通过前端路由的配置，我们可以实现页面的按需加载，无需一开始加载首页便加载网站的所有的资源，服务器也不再需要解析前端页面，在页面交互及用户体验上有所提升。

3.降低维护成本。通过目前主流的前端MVC框架，我们可以非常快速的定位及发现问题的所在，客户端的问题不再需要后台人员参与及调试，代码重构及可维护性增强。

4.实现高内聚低耦合，减少后端（应用）服务器的并发/负载压力。

5.即使后端服务暂时超时或者宕机了，前端页面也会正常访问，但无法提供数据。

## tinymce的协同编辑

难点

## tinyMCE遇到的问题

为了加快页面载入速度就要首先解决载入文件过多的问题，而大部分时间用户并不需要每次打开页面都先加载一遍editor的核心文件，
而editor本身也要按需加载内容.
把源码下载下来，做成异步组件
导入的过程遇到theme.js 路径不对的问题。
在默认配置下， tinymce载入的theme的路径居然是这个

```JS
Request URL:<http://localhost:8080/themes/modern/theme.js>
```

改成cdn路径

```javascript
window.tinymce.baseURL = 'http://cdn.xxx.com/static/tinymce'
复制代码
```

然后把plugins包和tinyMce主体包在不阻塞页面加载的情况下，做个懒加载提前缓存好文件方便后面使用，而组件本身在挂载前做个监听window.tinymce全局变量的方法，然后cdn控制下文件的过期时间即可。

本地开发环境，谷歌和火狐浏览器都能完美兼容，打包后谷歌浏览器没问题，火狐浏览器存在问题，报的是ip+/themes/modern/theme.js 找不见。

解决方法：

在当前组件配置baseURL：

判断开发环境还是生产环境，改变引用资源的相对路径，保证富文本能加载到所需资源文件.

if (process.env.BASE_API.indexOf(‘openManage’) >= 0) {

window.tinymce.baseURL = ‘./static/js’;

}

### 遇到的难点： 多实例

tinyMCE.activeEditor.setContent(val);会导致后面每一行数据的编辑的富文本内容都不会变,一直是第一次点击编辑的富文本内容
