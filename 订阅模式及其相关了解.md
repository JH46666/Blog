# 前端常见设计模式之发布订阅模式

## 基础

    观察者模式是对象的行为模式，又叫发布订阅者模式，模型视图模式，监听者模式或者Dependents模式。

### object.observe()

  object.observe API可以被称为一种“可以对任何对象的属性值修改进行监视的事件处理函数”。
  可以观察的改变有 6 种变化

  1. add
  2. update
  3. delete
  4. reconfigure
  5. setPrototype
  6. preventExtensions

```js
var obj = {
    a: 1,
    b: 2
};
Object.observe(
    obj,
    function(changes) {
        for (var change of changes) {
            console.log(change);
        }
    },
    ["add", "update", "delete"]
);
obj.c = 3; {
    name: "c",
    object: obj,
    type: "add"
}
obj.a = 42; {
    name: "a",
    object: obj,
    type: "update",
    oldValue: 1
}
delete obj.b; {
    name: "b",
    object: obj,
    type: "delete",
    oldValue: 2
}
```

我们也可以自建监听事件

``` js
var obj3 = {
    _time: new Date(0)
};
var notifier = Object.getNotifier(obj3); //获取Notifier对象

Object.defineProperties(obj3, { //设置对象的可访问属性
    _time: {
        enumerable: false,
        configrable: false
    },
    seen: {
        set: function(val) {
            var notifier = Object.getNotifier(this);
            notifier.notify({
                type: 'time_updated', //定义time_updated事件
                name: 'seen',
                oldValue: this._time
            });
            this._time = val;
        },
        get: function() {
            return this._time;
        }
    }
});
Object.observe(obj3, function output(changes) {
    changes.forEach(function(change, i) {
        console.log(change, i)
    });
}); //为对象指定监视时调用的回调函数
obj3.seen = new Date(2013, 0, 1, 0, 0, 0); //触发time_updated事件
obj3.seen = new Date(2013, 0, 2, 0, 0, 0); //触发time_updated事件
obj3.seen = new Date(2013, 0, 3, 0, 0, 0); //触发time_updated事件
obj3.seen = new Date(2013, 0, 4, 0, 0, 0); //触发time_updated事件

```

代理是可以在动作发生之前拦截的。对象观察支持在变化(或一组变化)发生后响应。

### object.defineProperty

  object.defineProperty(obj, prop, descriptor)
  obj: 定义属性的对象
  prop: 定义或修改的属性的名称
  descriptor：将被定义或修改的属性描述符

  默认情况下，object.defineProperty()添加的属性值是不可修改的。

  对象存在两种熟悉描述符：

  + 数据描述符  数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。
  + 存取描述符 存取描述符是由getter-setter函数对描述的属性。

  
  描述符必须是这两种形式之一；不能同时是两者。

  数据描述符 和 存取描述 都具有

  + configure 为true时，该属性描述符才能改变，默认为false
  + enumerable 为true时，该属性能够出现在对象的枚举属性中，默认为false

  数据描述符：

  + value 可以是任何有效的 javascript，默认为undefined
  + writable 当且仅当为 true时， value才能被赋值运算符改变，默认为false

  存取描述符：

  + get 给一个属性提供getter方法，如果没有 getter 则为 undefined。方法执行时没有参数传入，但是会传入this对象 默认为undefined
  + set 给一个属性提供setter方法，当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。

### object.proxy

``` js
    const me = {
        name: "小明",
        like: "小红 ",
        food: "香菇",
        musicPlaying: true
    };

    const meWithProxy = new Proxy(me, {
        get(target, prop) {
            if (prop === "like") {
                return "学习";
            }
            return target[prop];
        }
    });
    const meDontProxy = new Proxy(me, {
        set(target, prop, value) {
            if (prop === "musicPlaying" && value !== true) {
                console.log('value: ',target[prop], value);
                throw Error("音乐不停，生命不息！");
            }
        }
    });

    console.log("proxy", meWithProxy.food);
    console.log("proxy", meWithProxy.like); //target为like时，代理为学习
    console.log("proxy", meDontProxy.musicPlaying = false); //修改为false， 出现错误。
```

### 事件委托

``` js
//event.js

class Event {
    /** on 方法把订阅者所想要订阅的事件及相应的回调函数记录在 Event 对象的 _cbs 属性中*/
    on(event, fn) {
        if (typeof fn != "function") {
            console.error('fn must be a function')
            return
        }
        this._cbs = this._cbs || {};
        (this._cbs[event] = this._cbs[event] || []).push(fn)
    }
    /**emit 方法接受一个事件名称参数，在 Event 对象的 _cbs 属性中取出对应的数组，并逐个执行里面的回调函数 */
    emit(event) {
        this._cbs = this._cbs || {}
        var callbacks = this._cbs[event],
            args
        if (callbacks) {
            callbacks = callbacks.slice(0)
            args = [].slice.call(arguments, 1)
            for (var i = 0, len = callbacks.length; i < len; i++) {
                callbacks[i].apply(null, args)
            }
        }
    }
    /** off 方法接受事件名称和当初注册的回调函数作参数，在 Event 对象的 _cbs 属性中删除对应的回调函数。*/
    off(event, fn) {
        this._cbs = this._cbs || {}
        // all
        if (!arguments.length) {
            this._cbs = {}
            return
        }
        var callbacks = this._cbs[event]
        if (!callbacks) return
        // remove all handlers
        if (arguments.length === 1) {
            delete this._cbs[event]
            return
        }
        // remove specific handler
        var cb
        for (var i = 0, len = callbacks.length; i < len; i++) {
            cb = callbacks[i]
            if (cb === fn || cb.fn === fn) {
                callbacks.splice(i, 1)
                break
            }
        }
        return
    }
}

const myEvent = new Event();
export default myEvent;

必须导出 实例对象 类似 dio
```

jquery

``` 

```

flutter 的ps

``` js

```


  监听者（observer）: 对数据增加 getter  和  setter，以及往观察者列表中增加观察者，当数据变动时去通知观察者列表。
  观察者列表(Dep): 这个模块的主要作用是维护一个属性的观察者列表，当这个属性触发getter时将观察者添加到列表中，当属性触发setter造成数据变化时通知所有观察者，
  观察者（watch）：这个对数据进行观察，一旦收到数据变化的通知就会去改变视图.
