
##

![执行渲染时间](https://tva1.sinaimg.cn/large/0081Kckwgy1gk8m3lhldsj311o0lkq4q.jpg)
FCP：首次内容绘制时间，TTI：可交互时间


常见的拆解方式是用户从浏览器发起的请求阶段、服务端渲染阶段和响应阶段

* 请求已经到到达服务还未执行渲染
* 开始渲染计算，直到渲染完成
* 服务器处理响应



渲染前：
缓存： 数据、组件、页面
请求：http、keep-alive
降级： 客户端渲染


在不考虑自研 CDN 的情况下，开启 CDN 缓存的步骤非常简单：

域名接入 CDN 服务，同时针对路径启用缓存
在源站设置 Cache-Control 响应头，为了更灵活地控制缓存规则，但并不是必须

什么服务可以开启 CDN 缓存

* 无用户状态
* 低时效性


从下面几个方面

1. 缓存时间
提高 Cache-Control 的时间是最有效的措施，缓存持续时间越久，缓存失效的机会越少。Cache-Control 只能告知 CDN 该缓存的时间上限，并不影响它被 CDN 提早淘汰。流量过低的资源，很快会被清理掉，CDN 用逐级沉淀的缓存机制保护自己的资源不被浪费。

2. 忽略 url 参数
  页面的参数明显不符合预期， 例如微信等渠道分享后，末尾被挂上各种渠道自身设置的统计参数。 平均到单个资源的访问量就会大大降低，进而降低了缓存效果。

3. 主动缓存
化被动为主动，才有可能实现 100% 的缓存命中率。常用的主动缓存是资源预热，更适合 URL 路径明确的静态文件，动态路由无法交给 CDN 智能预热，除非依次推送具体的地址。

## 应用代码层面

1. 掌控缓存

```js
app.use((ctx, next) => {
  if(['/foo', '/foo/'].includes(ctx.patch)){
    ctx.set('Cache-Control', 'max-age=300')
  }
})




```