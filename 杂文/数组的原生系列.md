//原生系列

Array.prototype.slice = function (start, end) {
  var result = new Array();
  var start = start || 0;
  var end = end || this.length;
  for (var i = start; i < end; i++) {
    result.push(this[i]);
  }
  return result;
}

function arg2arr() {
  console.log(arguments);
  var arr = Array.prototype.slice.call(arguments);
  console.log(arr)
}
arg2arr(1, 2, 3)

Array.prototype.log = function () {
  return console.log('hello sjh')
}

//这个技巧可以很巧妙的改变入参  运用了数组的一些原生方法
function foo(...args) {
  // args已经是一个真正的数组

  args.log();
  //丢弃args中的第一个元素
  // args.shift();

  //把整个args作为参数传递给console.log（..）
  console.log(...args);
}
foo(1, 2, 3, 4, 5)
// 这里运用了运算符...对称而又相反的用法


slice的几个特性：1.不改变原数组 2.参数从指定位开始，不包含指定位结束。3.返回值为截取出来的元素的集合

splice(start, deleteCount, item1, item2):  1.返回新数组2. start开始的位置，deletCount要截取的个数，后面items为要添加的元素3.如果deleteCount为0，则表示不删除元素，从start位置开始添加后面的几个元素到原始的数组里面

//例子
        var arr3 = [1,2,3,4,5,6,7,"f1","f2"];
        var arr4 = arr3.splice(2,3) //删除第三个元素以后的三个数组元素(包含第三个元素)
        console.log(arr4); //[3,4,5];
        console.log(arr3); //[1,2,6,7,"f1","f2"]; 原始数组被改变

        var arr5 = arr3.splice(2,0,"wu","leon"); 
        //从第2位开始删除0个元素，插入"wu","leon"
        console.log(arr5); //[] 返回空数组
        console.log(arr3); // [1, 2, "wu", "leon", 6, 7, "f1", "f2"]; 原始数组被改变

        var arr6 = arr3.splice(2,3,"xiao","long");
        //从第2位开始删除3个元素，插入"xiao","long"
        console.log(arr6); //["wu", "leon", 6]
        console.log(arr3); //[1, 2, "xiao", "long", 7, "f1", "f2"]

        var arr7 = arr3.splice(2);//从第三个元素开始删除所有的元素
        console.log(arr7);//["xiao", "long", 7, "f1", "f2"]
        console.log(arr3); //[1, 2]
