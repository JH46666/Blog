


## 
除此之外，关于“树”，还有三个比较相似的概念：高度（Height）、深度（Depth）、层（Level）。它们的定义是这样的：

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj4h0pfnenj30vq0fp757.jpg)

“高度”这个概念，其实就是从下往上度量，比如我们要度量第 10 层楼的高度、第 13 层楼的高度，起点都是地面。所以，树这种数据结构的高度也是一样，从最底层开始计数，并且计数的起点是 0。

“深度”这个概念在生活中是从上往下度量的，比如水中鱼的深度，是从水平面开始度量的。所以，树这种数据结构的深度也是类似的，从根结点开始度量，并且计数起点也是 0。

“层数”跟深度的计算类似，不过，计数起点是 1，也就是说根节点位于第 1 层。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gj4h11qcpxj30vq0fu3yl.jpg)

完全二叉树的定义: 叶子节点都在最底下两层, 最后一层的叶子节点都靠左排列,并且除了最后一层,其他层的节点个数都要达到最大.
满二叉树的定义: 除了叶子节点,每个节点都有左右两个子节点.

存储一棵二叉树，我们有两种方法，一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法。

比较简单、直观的链式存储法。

![链式](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjnp35ghvnj30u20jk402.jpg)

基于数组的顺序存储法:
![顺序](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjnp5a2nuij30u60g2wfc.jpg)

堆和堆排序 堆是一种完全二叉树,最常用的存储方式就是数组

前序遍历 中序遍历 和 后序遍历

* 前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。

* 中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。

* 后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。

![前中后](https://tva1.sinaimg.cn/large/007S8ZIlgy1gjnpwguvftj30u60geq61.jpg)


写递归代码的关键，就是看能不能写出递推公式，而写递推公式的关键就是，如果要解决问题 A，就假设子问题 B、C 已经解决，然后再来看如何利用 B、C 来解决 A。所以，我们可以把前、中、后序遍历的递推公式都写出来
```js

前序遍历的递推公式：
preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)

中序遍历的递推公式：
inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)

后序遍历的递推公式：
postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r

```

前、中、后序遍历的时间复杂度是O(n)


红黑树: 平衡二叉查找树 

平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。

红黑树的英文是“Red-Black Tree”，简称 R-B Tree。它是一种不严格的平衡二叉查找树，

* 根节点是黑色的；
* 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；
* 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
* 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；

AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，AVL 树为了维持这种高度的平衡，就要付出更多的代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了。

红黑树规定, 插入的节点必须是红色的, 而且,二叉查找树中新插入的节点都是放在叶子节点上.

* 如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义。
* 如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了。


递归树

归并排序递归树是一棵满二叉树

讲到，满二叉树的高度大约是 log2​n，所以，归并排序递归实现的时间复杂度就是 O(nlogn)




