
let foo: unknown;
foo = 1;


// any vs unknown
// any >>> 传染性

// js > ts 重构
//unknown 会增加开发者的心智负担

// type
type XOR<T, U> = (T | U) extends object
type XOR<T, U> = (T | U) extends object


// extends object
type _T4 = { name: 'hoel'} extends {} ? 1 : 2;

type _T3 = 1|2 extends 1|2|3 ? 1:2;

// 字符串字面量类型
type _T2 = 'hoel' extends string ? 1:2;

// as 只用于转换存在子类型关系的两个类型
// extends 通过结构化类型
const a = new Base() as Derived;


// 

// 入门 写基础类型， 写interface 简单的类型功能 as 重债

开始有意识的了解类型系统和类型变成变成的知识

看懂内置 到能自己写， 到能写出比较复杂的工具类型

//>>> 进阶
跨度大 
类型系统的表现
分布式条件类型为什么这么设计




2022-02-26-11-24-40.png

2022-02-26-11-26-14.png

2022-02-26-11-56-55.png

2022-02-26-12-00-45.png

2022-02-26-12-01-53.png


2022-02-26-12-19-00.png

2022-02-26-12-21-21.png

2022-02-26-12-22-26.png

2022-02-26-12-23-25.png

2022-02-26-12-29-04.png

2022-02-26-12-31-09.png

2022-02-26-12-39-52.png

2022-02-26-12-42-35.png

2022-02-26-12-47-58.png




![](2022-02-26-11-43-57.png)

![](2022-02-26-11-48-45.png)


![](2022-02-26-11-50-08.png)


![](2022-02-26-11-50-33.png)

![](2022-02-26-11-56-04.png)



