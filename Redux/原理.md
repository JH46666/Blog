redux 原理:

``` js
store 实例持有当前状态

const createStore = (reducer) => {
    let state = {};
    let listeners = []

    getState = () => state;

    dispatch(listener) {
            state = reducer(state, action);
            listeners.forEach(listener => listener())
        },

        subscribe(listener) {

            listeners.push(listener)

            return () => {
                listeners = listeners.filter(item => {
                    item !== listener
                })
            }
        }

    return {
        getState,
        dispatch,
        subscribe
    }
}

if (process.env.NODE_ENV＝＝ 'production'） {
        const store.dispatch = addLoggingToDispatch(store);
    }

    addLoggingToDispatch(store) => {
        const rawDispatch = store.dispatch;

        if (!console.log(group)) {
            return rawDispatch
        }

        return (action) => {
            console.log('dayin', get.state())

            //调用原始的 dispatch 并记录返回值
            const returnValue = rawDispatch(action);

            console.log('dayin', get.state())
            return returnValue
        }
    }

    addPromiseDispatch(store) => {
        const rawDispatch = store.dispatch;

        return (action) => {
            if (typeof action.then() == 'function') {
                return action.then(rawDispatch)
            }

            return rawDispatch(action)
        }
    }
```

  我们可以将这种包装过程收敛 -- 声明一个数组, 即中间件数组
Redux 核心思想就是将 dispatch 增强改造的函数（中间件）先存起来，然后提供给
Redux, Redux 负责依次执行. 这样每一个中间件都对 dispatch 一次进行改造, 并将改造后的 dispatch 即 next 向下传递, 即将控制权转移给下一个中间件, 完成进一步的增强

```js      
const configureStore = () => ( 
  const store= createStore(App) ; 
  const middlewares = []; 
  if (process . env . NODE_ENV !== 'production') { 

    middlewares.push(addLoggingToDispatch);

  }
  middlewares.push(addPromiseSupportToDispatch); 
  wrapDispatchWithMiddlewares(store , middlewares)  
  return store; 
}

``` 

wrapDispatchWithMiddlewares 接收一个 middlewares 数组 和最纯净的 store.dispatch

```js
const wrapDispatchWithMiddlewares = (store, middlewares) =>{
  middlewares.slice().reverse().forEach(middleware => 
    store.dispatch = middleware(store)(store.dispatch)
  )
}

  const promise = (store) => (next)=> (action)=>{
    return (action)=>{
      if( typeof action.then() == 'function'){
        return action.then(next)
      }

      return next(action)
    }
  }

  const logger = (store)=> (next)=>{
      if(!console.log(group)){
        return next
      }
      return (action) => {
        console.log('dayin', get.state())

        //调用原始的 dispatch 并记录返回值
        const returnValue = next(action );

        console.log('dayin', get.state())
        return returnValue
      }
  }

```

```js
export default function applyMiddleware(...middlewares){
  return (next) => 
    (reducer, initialState) => {
      var store = next(reducer, initialState);
      var dispatch = store.dispatch;
      var chain = [];

      var middlewareAPI = {
        getState: store.getState,
        dispatch: (action) => dispatch(action)
      }

      chain = middlewares.map(middleware => middleware(middlewareAPI));

      dispatch = compose(...chain, store.dispatch);

      return {
        ...store,
        dispatch
      }
    }
}
```
middlewareAPI 是第三方中间件需要使用的参数，即原始的 store.getState 和 dispatch 方法，
这些参数在中间件中是否会全部应用到，自然要看每个中间件的应用场景和需求。

chain 数组中的每一项都是对原始 dispatch 的增强,并进行控制权转移. 所以就有了 dispatch = compose(...chain, store.dispatch)

这里的 dispatch 函数就是增强后的 dispatch. 因此, compose 方法接收了 chain 数组和原始的 store.dispatch 方法.


```js
export default function compose (...funcs){
  if(funcs.length === 0){
    return arg => arg
  }

  if(funcs.length === 1){
    return funcs[0]
  }

  return funcs.reduce((a, b) => (...args) => a(b(...args)))
}

```

写一个中间件的套路
```js
const customMiddleware = store => next => action => {}
```

```js
store.dispatch({
  type: 'CHANGE_THEME',
  payload: 'light'
})


const CHANGE_THEME = store => next => action => {
  //拦截目标 action

  if(action.type  === 'CHANGE_THEME'){
    if(localStorage.getItem('theme') !=== action.payload){
      localStorage.setItem('theme', action.payload)
    }
  }

  return next(action)
}

// 业务初始化的时候
store.dispatch({
  type: 'CHANGE_THEME',
  payload: localStorage.getItem('theme') || 'dark'
})

```

## 可组合的 reducer

我们可以记录每一个 action 和状态,当程序出现问题时, 首先查询究竟是哪一个状态发生错误,然后回溯,看前一个触发错误的 action 是否准确.因为 action 都是 JavaScript 对象,完全可读,所以我们完全有能力识别出 action 的正确性.
在持久性方面 数据采用 JavaScript
象来存储，可以方便地使用 Ison parse 等相关序列 方法，可以在任何需要数据的地方进行
载。同时，对于同构渲染，我们也可以在服务端就进行状态的设定，完成服务端直 。当页
面出现错误时，我们可以用典型的 try ... catch 捕获错误，并记录当前的状态以及 action ，这对于
生成页面错误报告也是非常有意义 对于优化共 ，我们可以设想这样的场景：在页面中，
一个用户可以点击关注按钮去关注另外一个用户。在点击关注之后 ，可以在发送网络请求之前
便对 state 进行最初的更改，同时把相关的 action 记录在一个队列中 ，稍后再发送关注的请求
如果请求最终失败，则返回相应的状态，并提示用户.

```js
const getVisibleTodos = (state , filter) => { 
  switch (filter) { 
    case  'all' :
    return state ; 
    case 'completed' : 
    return state.filter => (t => t.completed) ;
  }
}
```

```js
const undoable = (reducer) => {
  const initialState = {
    past: [],
    present: reducer(undefined, {})
  }

  return (state = initialState, action) => {
    const { past, present} = state;
    if(action.type === 'UNDO'){
      return {
        past: past.slice(0, -1),
        present: past[past.length - 1]
      }
    }
    return {
      past: [...past, present],
      present: reducer(present, action)
    }
  }
}
```

## react-redux
将所有的业务组见嵌套在由 react-redux 提供的 provider 组件当中,并将所生成的 store 设置为 provider 组件的参数, provider 组件便感知到 store.

context 用来使 react 子孙组件可以直接"越级"获取父组件的信息,这样就不需要一层层通过 props 向下传递.
核心目标是使 props.store 放到 context 中; connect 作为一个柯理化的高级函数,可以根据一级参数计算筛选出 store 信息,根据二级参数 component 返回一个高级组件 connectComponent 即可


## 同构应用
就是用户必须等待 Java Script 脚本加载完成，且真正执行时才会发起数据请求。接下来，等待
数据成功返回后，脚本完成页面内容渲染，用户才可以得到最终页面。这样做直接降低了页面
首屏展现的时间，特别是在移动互联网环境下，对首屏加载性能的影响很大。

不利于 SEO 和存在性能问题
页面的数据内容主要由 JavaScript 脚本动态生成,因此非常不利于搜索引擎获取该页面的信息.
且对首屏加载性能的影响很大

服务端渲染技术会把数据请求过程放在服务端，相对于前后端分离的方式，获取数据更加
提前，页面模板结合数据的渲染处理也在服务端完成。结合 React 技术，基本的组件拼接在服
务端完成 并最终输出相对完整的 HTML 返回给浏览器端。

服务端渲染主要侧重架构层面的实现，而同构更侧重代码复用

所谓同构，就是指前后端共用一套代码或逻辑，而在这套代码或逻辑中，理想的状况是在浏览器端进一步渲染的过程中，判断己有的 DOM 结构和即将渲染出的结构是否相同，若相同，则不重新渲染 DOM结构，只需要进行事件绑定即可.

同构更像是服务端渲染和浏览器渲染的交集, 它弥补了服务端和浏览器端的差异,从而使得同一套代码或逻辑得以统一运行.



















