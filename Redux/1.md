# 状态容器与数据流管理

## 三大原则
1. 单一数据源;
2. 状态不可变
3. 纯函数修改状态

先创建 action

actionCreactors = 在用dispatch 调用 action;


const props = {a:1, b:2};
然后：

<Control {...props}/>
就相当于：

<Control a={props.a} b={props.b}>

一般来说，在程序设计中，我们会不知不觉地设定一些简单的协议，来进行两个模块之间的通信。比如A模块传递给B模块一些信息，B模块要根据不同的信息类型来执行不同的操作，我们会这么写：

function notifyB(data) {
    if (data.type === 'add') {}
    else if (data.type === 'remove) {}
}
这样设计，我们就不必为每一种操作都写一个函数，那么这里的data就是一种协议的体现，也就是相当于redux中的action，action是一种只有两个字段type和payload的结构体。显然，创建action结构的函数，就叫做actionCreator。向action的消费方，也就是B模块，传递action的方法，即notifyB，就是一种dispatch的简单示例。

reducer的initState只有在store中不存在这个state的时候才会被用到。preloadState顾名思义就是初始化store数据的，这样就不必在初始化app的时候手动执行多个action去set数据了，比如说从server拉取数据并初始化store，这个参数就是一个很好用的方式。

export导出对象的每个key就是reducer纯函数。合并reducer的API传入的参数就是


prop-type


那么一定有一个类似于 store. makeN ewState 的方法吧？其实， Redux 生成一个全新的页面
状态数据对象进行了拆解，它规定： 当页面需要展现新的数据状态时 ，我们只 需要 dispatch （派
发〉一个 actio （动作／事件）即可。这个 action 其实也是一个 JavaScript 就像页面状态数
据树这个 JavaScript 对象描述了整个页面的状态一样， action 则描述了这个动作单元变化的所有
信息。

使用 reducer 数来接收 action ，并执行页面状态数据树的变更。经 reducer 函数处理之
后， store.getState 方法就会返回新页面的数据状态。

reducer action 需要由开发者编写。 reducer 接收 以下两个参数
当前页面数据状态。
被派发 action
所以这个函数的处理可以抽象表达出来：
(previousState, action) => newState




![redux整体流程](https://tva1.sinaimg.cn/large/007S8ZIlgy1gierr9vr34j30me0f840l.jpg)






