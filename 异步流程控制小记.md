# 异步流程小记

  前端不可绕过的异步流程， 我们知道 javascript 运行在浏览器中，以 Google 浏览器为例子，
  v8 引擎，包含 内存堆： 这是内存分配发生的地方。 调用栈： 这是你代码执行的地方。

  运行一个函数时，解析器把该函数添加到栈中并且执行这个函数。

  Web APIs: DOM、AJAX、Timeout(setTimeout)

  js是一门单线程的语言， 这意味这它只有一个调用栈。

  当我们堆栈执行的函数需要大量时间时，浏览器会停止响应，幸运的是我们有异步回调。

  javaScript引擎 运行在宿主环境中（浏览器或者 node），
  CallbackQueue  and Event Loop

  事件循环和回调队列
  调用栈和回调队列，当栈为空时，它会调取出队列中的第一个事件，放到调用栈中执行

## 基础知识

为什么Promise的代码（microtask）会比setTimeout的代码（macrotask）更优先执行，因为它太机智了，竟然会插队！

## 环境配置

需要预先引入的库

  const fs = require('fs')
  const co = require('co')
  const util = require('util')

## callback（）

第一阶段：回调函数

``` javascript
function readFile(cb) {
    fs.readFile('./package.json', (err, data) => {
        if (err) return cb(err)
        cb(null, data)
    })
}

readFile((err, data) => {
    if (!err) {
        data = JSON.parse(data)
        console.log(data.name)
    }
})
```

## promise

第二阶段：Promise
定义阶段  promise（resolve， reject）分别成功或者失败时处理什么
调用阶段  通过then函数实现，成功就执行resolve， 它会将reslove的值传递给最近的then函数，作为then函数的参数。 如果出错reject，那么交给catch来捕获异常

  promise的要点如下

  1. 递归： 每个一步操作返回的都是promise对象
  2. 状态机： 三种状态peomise对象内部可以控制，不能在外部改变状态
  3. 全局异常处理

将回调函数中的结果延后到 then 函数里处理或交给全局异常处理

我们约定将每个函数的返回值都得是 promise 对象。 这可以理解为变种思想应用， 只要是 promise 对象， 就可以控制状态并支持 then 方法，将无限个 promise 对象链接在一起。

```javascript
hello('xx.html').then(log).then(function(){
  return world('./xxx.js').then(log)
}).catch(err=>{
  console.log(err)
})

```

每个 promise 对象都有 then 方法， 也就是说then方法是定义在原型对象promise.prototype上的， 它的作用是为
promise 实例添加状态改变时的回调函数

一般情况下，只传 success 回调函数即可，fail函数可选，使用catch来捕获函数异常比通过fail函数进行处理更加可控。

const requireDirectory = require(require-directory )
module.export = requireDirectory(module)

``` javascript
function readFileAsync(path) {
    return new Promise((resolve, reject) => {
        fs.readFile(path, (err, data) => {
            if (err) reject(err)
            else resolve(data)
        })
    })
}

readFileAsync('./package.json')
    .then(data => {
        data = JSON.parse(data)
        console.log(data.name)
    })
    .catch(err => {
        console.log(err)
    })
```

## co/generator

讲之前先来看一个es6的东西

``` javascript
  function* foo() {
      yield 1;
      yield 2;
      yield 3;
      return console.log(4)
  }

  var it = foo();
  it.next();
  it.next();
  it.next();
  it.next(); //4
```

注： co 是 tj 大神开发的库，github [地址：](https://github.com/tj/co)

```javascript
co(function * () {
  let data = yield util.promisify(fs.readFile)('./package.json')
  data = JSON.parse(data)
  console.log(data.name)
})

控制函数的执行过程，手工暂停和恢复代码执行
function* doSomething(){

	console.log(‘start’)
	yield
	console.log(‘finish’)

}
var func1 = doSomething(); 
func1.next(); 
func1.next(); 

function* getStorckPrice(stock){

	while(true){
	yield Math.random()*100;
	}

}
var priceGenerator = getStockPrice(‘IBM’); 
var limitPrice = 15; 
var price = 100; 
while(price > limitPrice){
  price = priceGenerator.next().value; 
  console.log( `this generator return ${price}` ); 
}
console.log( `buying at ${price}` ); 

```

## async/await

``` javascript
const readAsync = util.promisify(fs.readFile)
async function init() {
    let data = await readAsync('./package-lock.json')
    data = JSON.parse(data)
    console.log(data.name)
}
init()


```

我们用 babel 编译下，async/await转换出什么。

```js

//源代码
function tell(){
  return new Promise((reslove, reject)=>{
    if(true){
      reslove(1)
    } else{
      reject(2)
    }
  })
}

var a = (
  async() =>{
    await tell().then((res)=>{
      console.log('res',res);
    }).catch(err=>{
      console.log('err: ', err);
    })
  }
) 
console.log('a',a())


//转换后的
"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}

function tell() {
  return new Promise(function (reslove, reject) {
    if (true) {
      reslove(1);
    } else {
      reject(2);
    }
  });
}

var a =
  /*#__PURE__*/
  function () {
    var _ref = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return tell().then(function (res) {
                  console.log('res', res);
                })["catch"](function (err) {
                  console.log('err: ', err);
                });

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

    return function a() {
      return _ref.apply(this, arguments);
    };
  }();

console.log('a', a());

```
   
    yeah，瞬间好长一串，不过莫慌。我们先理性（慌张）分析一波。
    它先定义了 三个个函数 asyncGeneratorStep、 _asyncToGenerator、tell
    wow， 我们发现就tell这个函数我们看的懂，而且很熟悉， Promsie（不熟悉的先去补补上面的知识），ok，
    在看剩下来的两个函数。我们大概分析下，asyncGeneratorStep 这个应该是根据不同的状态我们要怎么处理（做具体的事情）。 _asyncToGenerator、tell 这个函数呢，则是将传入的函数变量做分配处理，起分配作用。（不做具体事情）。 

    接来下我们看看 a定义的这个主函数。整个采用了switch模式，根据不同的状态，分发事件。
    regeneratorRuntime ，这是啥， 我们 Google 了一下，这个是 facebook 下的一个工具，用于编译 ES6 的 generator 函数。

    我们进行下载

    npm install -g regenerator

    然后创建一个generator,js文件

  ```js
    function  *hiGenerator() {
      yield '1';
      yield '2';
      return '3';
    }
  ```
    执行 
    regenerator  geberator.js  > generator-es5.js

    以下称为编译简单版， 这个肯定是不能跑的，因为有我们遇到的 regeneratorRuntime。wap. 

  ```js
    "use strict";

      var _marked =
      /*#__PURE__*/
      regeneratorRuntime.mark(hiGenerator);

      function hiGenerator() {
        return regeneratorRuntime.wrap(function hiGenerator$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return '1';

              case 2:
                _context.next = 4;
                return '2';

              case 4:
                return _context.abrupt("return", '3');

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _marked);
      }

  ```
          
      regenerator --include-runtime  geberator.js  > generator-es5.js


      可以得出一个编译后 700 多行的点东西，我们抽离除主要逻辑

  ```js

  var _marked =
  /*#__PURE__*/
  regeneratorRuntime.mark(hiGenerator);

  ```
    还有

  ```js
  function hiGenerator() {
    return regeneratorRuntime.wrap(function hiGenerator$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return '1';

          case 2:
            _context.next = 4;
            return '2';

          case 4:
            return _context.abrupt("return", '3');

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _marked);
  }
   ```
  
  ```js

  function wrap(innerFn, outerFn, self, tryLocsList) {

    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  ```
  所以当我们 const hell = hllGenerator() 的时候，执行的其实是 wrap 函数，wrap 函数返回一个 generator， generator 对象，她有 outerFn、outerFn
  
  
  我们在用