# 异步流程小记

  前端不可绕过的异步流程， 我们知道 javascript 运行在浏览器中，以 Google 浏览器为例子，
  v8 引擎，包含 内存堆： 这是内存分配发生的地方。 调用栈： 这是你代码执行的地方。

  运行一个函数时，解析器把该函数添加到栈中并且执行这个函数。

  Web APIs: DOM、AJAX、Timeout(setTimeout)

  js是一门单线程的语言， 这意味这它只有一个调用栈。

  当我们堆栈执行的函数需要大量时间时，浏览器会停止响应，幸运的是我们有异步回调。

  javaScript引擎 运行在宿主环境中（浏览器或者 node），
  CallbackQueue  and Event Loop

  事件循环和回调队列
  调用栈和回调队列，当栈为空时，它会调取出队列中的第一个事件，放到调用栈中执行

## 基础知识

为什么Promise的代码（microtask）会比setTimeout的代码（macrotask）更优先执行，因为它太机智了，竟然会插队！

## 环境配置

需要预先引入的库
const fs = require('fs')
const co = require('co')
const util = require('util')

## callback（）

第一阶段：回调函数

``` javascript
function readFile(cb) {
    fs.readFile('./package.json', (err, data) => {
        if (err) return cb(err)
        cb(null, data)
    })
}

readFile((err, data) => {
    if (!err) {
        data = JSON.parse(data)
        console.log(data.name)
    }
})
```

## promise

第二阶段：Promise
定义阶段  promise（resolve， reject）分别成功或者失败时处理什么
调用阶段  通过then函数实现，成功就执行resolve， 它会将reslove的值传递给最近的then函数，作为then函数的参数。 如果出错reject，那么交给catch来捕获异常

  promise的要点如下

  1. 递归： 每个一步操作返回的都是promise对象
  2. 状态机： 三种状态peomise对象内部可以控制，不能在外部改变状态
  3. 全局异常处理

将回调函数中的结果延后到 then 函数里处理或交给全局异常处理

我们约定将每个函数的返回值都得是 promise 对象。 这可以理解为变种思想应用， 只要是 promise 对象， 就可以控制状态并支持 then 方法，将无限个 promise 对象链接在一起。

```javascript
hello('xx.html').then(log).then(function(){
  return world('./xxx.js').then(log)
}).catch(err=>{
  console.log(err)
})

```

每个 promise 对象都有 then 方法， 也就是说then方法是定义在原型对象promise.prototype上的， 它的作用是为
promise 实例添加状态改变时的回调函数

一般情况下，只传 success 回调函数即可，fail函数可选，使用catch来捕获函数异常比通过fail函数进行处理更加可控。

const requireDirectory = require(require-directory )
module.export = requireDirectory(module)

``` javascript
function readFileAsync(path) {
    return new Promise((resolve, reject) => {
        fs.readFile(path, (err, data) => {
            if (err) reject(err)
            else resolve(data)
        })
    })
}

readFileAsync('./package.json')
    .then(data => {
        data = JSON.parse(data)
        console.log(data.name)
    })
    .catch(err => {
        console.log(err)
    })
```

## co/generator

讲之前先来看一个es6的东西

``` javascript
  function* foo() {
      yield 1;
      yield 2;
      yield 3;
      return console.log(4)
  }

  var it = foo();
  it.next();
  it.next();
  it.next();
  it.next(); //4
```

注： co 是 tj 大神开发的库，github [地址：](https://github.com/tj/co)

```javascript
co(function * () {
  let data = yield util.promisify(fs.readFile)('./package.json')
  data = JSON.parse(data)
  console.log(data.name)
})

控制函数的执行过程，手工暂停和恢复代码执行
function* doSomething(){

	console.log(‘start’)
	yield
	console.log(‘finish’)

}
var func1 = doSomething(); 
func1.next(); 
func1.next(); 

function* getStorckPrice(stock){

	while(true){
	yield Math.random()*100;
	}

}
var priceGenerator = getStockPrice(‘IBM’); 
var limitPrice = 15; 
var price = 100; 
while(price > limitPrice){
  price = priceGenerator.next().value; 
  console.log( `this generator return ${price}` ); 
}
console.log( `buying at ${price}` ); 

```

## async/await

``` javascript
const readAsync = util.promisify(fs.readFile)
async function init() {
    let data = await readAsync('./package-lock.json')
    data = JSON.parse(data)
    console.log(data.name)
}
init()
```
